<!DOCTYPE html>
<html lang="en" class="-debug">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>URL Reverse Specification</title>
  <link rel="stylesheet" href="style/base.css">
  <link rel="stylesheet" href="style/style.css">
</head>
<body>
  
<h1>URL Reverse Specification</h1>

<section>
  <p>
    This document provides a concise formal specification of URLs and the
    language of URLs. It is a <em>reverse specification</em> of the
    <a href="https://url.spec.whatwg.org/">WhatWG URL Standard</a>.
  <p class=-inbetween>
    The goals of this document are,
  <ul class=-runin>
    <li>
      To provide a modular, concise formal specification that is compatible
      with, and covers all of the <a href="https://url.spec.whatwg.org/">WhatWG
      URL Standard</a> with the one exception being their specification of the
      web API's setters and the url-encoded form format.
    <li>
      To define a general model for URLs that can express relative references
      and to define reference resolution by means of a number of elementary
      operations, in such a way that the end result is compatible with the
      WhatWG URL standard.
    <li>
      To enable and support efforts <em>towards</em> a single
      <strong><em>Unified URL Standard</em></strong> that includes a normative
      specification of URL handling by web browsers and that resolves the
      incompatibilites between
      <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>,
      <a href="https://tools.ietf.org/html/rfc3986">RFC 3987</a> and the
      <a href="https://url.spec.whatwg.org/">WhatWG URL Standard</a>.
    <li>
      To provide the authors of the WhatWG standard with a support document
      that they can use as a reference in their efforts to standardise the
      behaviour of web browsers.
  </ul>
</section>

<section><h2>Status of this document</h2>
  <ul>
    <li>
      The version of this document is 0.2.0.
    <li>
      The versioning scheme is specified by
      <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.
    <li>
      This document is licenced under a
      <a href="https://creativecommons.org/licenses/by/4.0/">
      Creative Commons - CC BY 4.0</a> licence. 
  </ul>
</section>

<section><h2>Structure of this document</h2>
  <p>
    As of this writing, this document has a compact format that is focused
    specifically on the definition and specification of URLs and operations on
    URLs. It does not include a discussion of their history or their use in
    various contexts. It does contain valuable non-normative references to
    <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a> that can be
    followed for additional information about the concepts involved.

  <p class=-inbetween>
    The sections are laid out as follows.
  <ul>
    <li>Preliminaries
    <li>URL Model
    <li>Reference Resolution
    <li>Parsing
    <li>Host Processing
    <li>Validation
    <li>Percent Coding
    <li>Printing
    <li>Normalisation
  </ul>
</section>

<section><h2>Preliminaries</h2>

<p>
  This section introduces basic concepts and notational conventions upon 
  which the rest of the specification is built. 

<h4>Strings</h4>
<p class=-line>
  For the purpose of this specification,
<ul>
  <li>
    A <dfn>string</dfn> is a sequence of <i>character</i>s.
  <li>
    A <dfn>character</dfn> is a single
    <a href="https://www.unicode.org/versions/latest/">Unicode</a> <i>code point</i>.
  <li>
    A <dfn>code point</dfn>, is a natural number <var>n</var> ≤ 1114111.
  <li>
    The <dfn>empty string</dfn> is a sequence of zero code points. It is
    denoted by ε.
</ul>
<p class="-inbetween -todo">
  NB ε is overloaded, it is used for empty sequences in
  general.
<p>
  Code points are denoted by a <em>hexadecimal</em> number in boldface, 
  preceded by <b>u+</b>. In addition, code points that correspond to
  printable <abbr class=-caps>ASCII</abbr>
  characters may be denoted literally, by their corresponding glyph typeset in
  monospace. For example, <b>u+41</b> and <code>A</code> denote the same
  code point. Strings that contain only printable
  <abbr class=-caps>ASCII</abbr> characters may be denoted litterally,
  likewise.
<p>
  The printable <abbr class=-caps>ASCII</abbr> characters are codepoints in the
  range <br> <b>u+21</b> to <b>u+7E</b>, inclusive. Note that this excludes the
  space character <b>u+20</b>.

<!-- <p><code>!&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
</code> -->

  <h4>Character Range</h4>
  <p>
    A <dfn>character range</dfn> is the largest set of characters that includes
    a given least character <var>c</var> and a greatest character <var>d</var>.
    Such a character range is denoted by {<var>c</var>–<var>d</var>}. 

  <h4>Tokens</h4>
  <p>
    The word <dfn>token</dfn> is used throughout this document to mean a
    tagged value, (<em>tag</em> <em>value</em>), where the <em>tag</em> is
    taken from a set of predefined <dfn>token-types</dfn>.
  <p>
    The value of a token may be a sequence of tokens itself, in which case
    the token may be referred to as a <dfn>compound token</dfn> for clarity.
    <!--and the tokens present in its value may be referred to as
    <dfn>sub-token</dfn>s.-->
  <p>
    When a collection of tokens contains exactly one sub-token
    (<em>tag</em> <em>value</em>) for a given tag, then the tag may be used
    to refer to its value directly. <br>For example, given a sequence of tokens
    S := ⟨<b>foo</b> <var>x</var>, <b>bar</b> <em>y</em>, <b>baz</b> <em>z</em>⟩, the prase
      &ldquo;the <b>bar</b> of S&rdquo; identifies the value <em>y</em>,  
      whereas the phrase
      &ldquo;the <b>bar</b> token of S&rdquo; identifies
      (<b>bar</b> <em>y</em>).

  <h4>Grammars</h4>
  <p>
    The notation <var>name</var> ::= <var>expression</var> is used to define
    the production rules of a grammar, where the <i>expression</i> uses
    square brackets ( [ _ ] ) <strong>for optional rules</strong>, a postfix
    star ( * ) for zero-or-more, a postfix plus ( + ) for one-or-more, an infix
    vertical line ( | ) for alternatives, monospaced type for literal strings
    and an epsilon ( ε ) for the empty string. Parentheses are used for 
    grouping and disambiguation. 

  <h4>Pattern Matching</h4>
  <p>
    The shorthand notation <var>string</var> :: <var>rule</var> is used to
    express that a string <var>string</var> can be generated by the production
    rule <var>rule</var> of a given grammar. 

  <h4>Common Character sets</h4>
  <p class=-line>
    Common character sets that are used throughout, are … 
  <table class=grammar>
    <tr><td>        any <td> := <td> { <b>u+0</b>–<b>u+10FFFF</b> }
    <tr><td>      alpha <td> := <td> { <code>A</code>–<code>Z</code>, <code>a</code>–<code>z</code> }
    <tr><td>      digit <td> := <td> { <code>0</code>–<code>9</code> }
    <tr><td>   hexdigit <td> := <td> { <code>0</code>–<code>9</code>, <code>A</code>–<code>F</code>, <code>a</code>–<code>f</code> }
    <tr><td> octaldigit <td> := <td> { <code>0</code>–<code>7</code> }
  </table>

  <h4 id="axioms-and-rewrite-rules">Axioms and Rewrite Rules</h3>
  <p>
    <div class=todo>
    A simple explanation of the notation
  </div>



</section>


<section><h2>URL Model</h2>
<p>
  An URL is a special kind of ordered list that is subject to a number of
  additional constraints. The ordering of the list is analogous to the
  hierarchical syntax of an URI as described in
  <a href="https://tools.ietf.org/html/rfc3986#section-1.2.3">Hierarchical
  Identifiers</a> in RFC 3986.
<p>
  It is important to stress the distinction between an URL and an URL-string.
  <br>
  An URL is a <em>structure</em>, indeed a special kind of ordered list,
  whereas an URL-string is a special kind of <em>string</em> that
  <em>represents</em> an URL. Conversions between URLs and URL-strings are
  described in the sections on <a href="#parsing">parsing</a> and
  <a href="#printing">printing</a>.

  <h4>URL</h3>
    <p>
      An <dfn>URL</dfn> is a sequence of tokens that occur in ascending order by token-type, where token-type is taken from the ordered set: 
    <p class="-center">
      <b>scheme</b> &lt; <b>authority</b> &lt; <b>drive</b> &lt; <b>path-root</b> &lt; <b>dir</b> &lt; <b>file</b> &lt; <b>query</b> &lt; <b>fragment</b>.

    <p>
      URLs are subject to the following constraints:
    <ul>
      <li>
        An URL contains at most one token per type, except for <b>dir</b>
        tokens.
      <li>An URL may have any finite amount of <b>dir</b> tokens.
      <li>
        If an URL has an <b>authority</b> or a <b>drive</b> token, and it
        has a <b>dir</b> or a <b>file</b> token, then it also has a
        <b>path-root</b> token.
    </ul>
    <ul>
      <li>
        The <dfn><b>scheme</b></dfn> of an URL, if present, is a string
        <var>scheme</var> :: alpha (alpha | digit | <code>+</code> | <code>-</code> | <code>.</code>)*
      <li>
        The <dfn><b>authority</b></dfn> of an URL, if present, is an
        <i>Authority</i> – to be defined below.
      <li>
        The <dfn><b>drive</b></dfn> of an URL, if present, is a string
        <var>drive</var> :: alpha (<code>:</code> | <code>|</code>)
      <li>
        The <dfn><b>file</b></dfn> of an URL, if present, is a nonempty string.
      <li>
        For all other tokens present, the tokens&rsquo; values are strings.
    </ul>

    <h4>Base URL</h4>
    <p>
      A <dfn>base URL</dfn> is an <i>URL</i> that has a <i><b>scheme</b></i>
      and in addition, an <i><b>authority</b></i> or a <i><b>path-root</b></i>.

    <h4>Authority</h4>
    <p class=-line>
      An <dfn>Authority</dfn> is a sequence of tokens ordered by their type, 
      taken from the ordered set:

    <p class="-center">
      <b>username</b> &lt; <b>password</b> &lt; <b>host</b> &lt; <b>port</b>.

    <p class=-line>
      Authorities are subject to the following constraints:
    <ul>
      <li>
        Authorities contain at most one token per type.
      <li>
        Authorities have exactly one <b>host</b> token. 
      <li>
        If an Authority has a <b>password</b> token then it also has a
        <b>username</b> token.
      <li>
        If an Authority has a <b>host</b> token whose value is the empty
        string, then it has no other tokens.
    </ul>

    <p class=-line>
      The tokens of an Authority are subject to the following conditions:
    <ul>
      <li>The <dfn><b>host</b></dfn> of an Authority is a <i>Host</i> – to be defined
        below.
      <li>
        The <dfn><b>port</b></dfn> of an Authority, if present, is either the
        empty string ε,<br>or a natural number <var>n</var> &lt; 2<sup>16</sup>.
      <li>For all other tokens present, the tokens&rsquo; values are strings.
    </ul>

  <h4>Host</h4>
  <p class=-line>
    A <dfn>Host</dfn> is either
  <ul>
    <li>the empty string,
    <li>an ipv6-address,
    <li>an opaque-host,
    <li>an ipv4-address, or
    <li>a domain-name.
  </ul>


<h3>Additional Constraints</h3>

<p class=-line>If an URL has a token (<b>scheme</b> <em>s</em>), then it is subject to two additional constraints:
<ul>
  <li>If <em>s</em>, converted to lowercase, is not <code>file</code> then the URL must not have a <b>drive</b> token.
  <li>If <em>s</em>, converted to lowercase, is <code>file</code> and the URL has an <b>authority</b> then the authority must not contain a <b>username</b>, <b>password</b> or <b>port</b>.
</ul>
</section>

<section><h2>Parsing</h2>
  <!--<ul>
    <li>An URL-string is a string that represents an URL.
    <li>There are strings that are not URL strings.
    <li>It is possible for a single URL to be represented by more than one URL string.
    <li>URL strings are further divided into valid URL strings and invalid URL strings.
  </ul>-->

  <p>Parsing is stratified into the following phases:

  <ol class=-inbetween>
    <li>Preprocessing.
    <li> Selecting the parser mode.
    <li> Parsing.
    <li> Detecting drive letters.
    <li> Decoding and parsing the host.
  </ol>

  <h3 id="preprocessing">Preprocessing</h3>

  <div class=todo>Preprocessing</div>

  <h3>Parameterised URL Grammar</h3>

  <p>
    The parser mode can be determined by &lsquo;sniffing&rsquo; a scheme from the input before parsing.
    This can be done in a multiple of ways. Implementors may choose to implement the mode selection within the parser itself.
    For this specification however, it is useful to specify it as a separate step, before parsing.

  <p class=-inbetween>Define the following rules.

  <table class=grammar>
    <tr><td>special-scheme <td> ::= <td> <code>http</code> | <code>https</code> | <code>ws</code> | <code>wss</code> | <code>ftp</code> | <code>file</code>
    <tr><td>is-special <td> ::= <td> special-scheme <code>:</code> any*
    <tr><td>has-scheme <td> ::= <td> alpha (alpha | digit | <code>+</code> | <code>-</code> | <code>.</code>)*<code>:</code> any*
  </table>

  <p class=-inbetween>The mode can be selected as follows.

  <ul>
    <li>Let <em>magic</em> be the first <em>n</em> characters of <em>input</em>, with <em>n</em> being min (6, input.length).
    <li>Set the parser mode to <b>special</b> if (lowercase <em>magic</em>) :: is-special.
    <li>Otherwise if the fallback scheme is <b>special</b> and <em>input</em> :: has-scheme, then set the parse mode to regular.
  </ul>

  <p>The grammar is parameterised by the parser mode. There are two parser modes, regular, and <b>special</b>. In <b>special</b> mode, the s subscripted rules must be used instead of their unsubscripted counterparts, whenever available.


  <h4 id="url-grammar">URL Grammar</h4>

    <table class=grammar>
      <tr><td>url <td> ::= <td> [ scheme <code>:</code> ] [ s s authority ] [ path-root ] (dir s)* [ file ] [ <code>?</code> query ] [ <code>#</code> fragment ]

      <tr class=-inbetween>
        <td colspan=3>This refers to the following rules:

      <tr><td>scheme <td> ::= <td> alpha (alpha | digit | <code>+</code> | <code>-</code> | <code>.</code>)*
      <tr><td>authority <td> – <td> shall be defined in the next subsection,
      <tr><td>drive <td> ::= <td> alpha (<code>:</code> | <code>|</code>) – to be used in a subsequent subsection
      <tr><td>path-root <td> ::= <td> slash
      <tr><td>dir <td> ::= <td> pchar*
      <tr><td>file <td> ::= <td> pchar+
      <tr><td>query <td> ::= <td> qchar*
      <tr><td>fragment <td> ::= <td> any*
      <tr><td>slash <td> ::= <td> <code>/</code>
      <tr><td>slash<sub>S</sub> <td> ::= <td> <code>/</code> | <code>\</code><sub>err</sub>

      <tr class=-inbetween><td colspan=3>These rules are based on the following character sets:

      <tr><td>qchar <td> := <td> any \ {<code>#</code>}
      <tr><td>pchar <td> := <td> any \ {<code>/</code>, <code>#</code>, <code>?</code>}
      <tr><td>pchar<sub>S</sub> <td> := <td> any \ {<code>/</code>, <code>\</code>, <code>#</code>, <code>?</code>}
    </table>

  <h4>Authority Grammar</h4>
    <table class=grammar>
      <tr><td>authority <td> ::= <td> [ credentials <code>@</code> ] host [ <code>:</code> port ]
      <tr><td>credentials <td> ::= <td> username [ <code>:</code> password ]

      <tr class=-inbetween><td colspan=3>This refers to the following rules:

      <tr><td>username <td> ::= <td> uchar*
      <tr><td>password <td> ::= <td> pchar*
      <tr><td>host <td> ::= <td> ε | <code>[</code> ip6-address <code>]</code> | opaque-host
      <tr><td>opaque-host <td> ::= <td> hchar+
      <tr><td>port <td> ::= <td> portchar*

      <tr class=-inbetween><td colspan=3>These rules are based on the following character sets:

      <tr><td>uchar <td> := <td> pchar \ { <code>:</code> }
      <tr><td>hchar <td> := <td> pchar \ { <code>@</code>, <code>:</code> }
      <tr><td>portchar <td> := <td> pchar \ { <code>@</code> }
    </table>

    <div class=todo>
      port, in this grammar as such, may contain non-digits.

    <ul>
      <li>resolve ambiguity (host/dir/file), or point it out
      <li>ipv6
      <li>Forbidden host codepoints
      <li>Evaluating the port
      <li>nonhost := { <b>u+0</b>, <b>u+9</b>, <b>u+A</b>, <b>u+D</b>, <b>u+20</b>, <code>#</code>, <code>/</code>, <code>:</code>, <code>&lt;</code>, <code>&gt;</code>, <code>?</code>, <code>@</code>, <code>[</code>, <code>\</code>, <code>]</code>, <code>^</code> }
    </ul>
  </div>


  <!--<section class=non-normative><h4>A note about repeated slashes</h4>

    <p>This is a non-normative sub-section.

    <p>Web browsers interpret any amount of slashes after a special scheme as the start of the authority component. Consider the following URL-strings:

    <ol class=-inbetween>
      <li><code>http:foo/bar</code>
      <li><code>http:/foo/bar</code>
      <li><code>http://foo/bar</code>
      <li><code>http:///foo/bar</code>
    </ol>

    <p>Web browsers treat all these examples as equivalent to 3: <code>http://foo/bar</code>.

    <p>It is tempting to express this behaviour on the level of the grammar. For example one might consider using the following rule:

    <ul>
      <li>url := [ scheme<code>:</code> ] [ s* authority ] [ path-root ] (dir s)* [ file ] [ <code>?</code>query ] [ <code>#</code>fragment ]
    </ul>

    <p>However, the examples 1. to 4. above <em>do</em> behave differently with respect to reference resolution. For example, if they are resolved agains the base URL represented by <code>http://host/</code>, then the results are as follows:

    <ol>
      <li><code>http://host/foo/bar</code>
      <li><code>http://host/foo/bar</code>
      <li><code>http://foo/bar</code>
      <li><code>http://foo/bar</code>
    </ol>

    <p>As such, collapsing the multiples of slashes, cannot be expressed within the grammar. The behaviour has to be defined semantically, as a part of the reference resolution operation.
  </section>-->
  </section>


  <h3 id="drive-letters">Drive letters</h3>

  <p>The grammar does not have rules for parsing windows drive letters in <code>file</code> URLs. It is possible to add that, but together with the mode selection, it would complicate the grammar quite a bit. An easier way to express this is via a separate operation on parsed URLs.

  <p>Drive letter detection, defined using pattern matching: 

  <table>
    <tr><td><b>authority</b> (<b>host</b> <var>x</var>) <td> ⇒ <td> <b>drive</b> <var>x</var> – if <var>x</var> :: drive-letter
    <tr><td><b>authority</b> (<b>host</b> <var>x</var>・<b>port</b> ε) <td> ⇒ <td> <b>drive</b> (<var>x</var>⧺<code>:</code>) – if <var>x</var> :: alpha
    <tr><td><var>xs</var>・<b>dir</b> <var>x</var> <td> ⇒ <td> <var>xs</var>・<b>drive</b> <var>x</var>・<b>path-root</b> <code>/</code> – if  <var>x</var> :: drive-letter and <var>xs</var> does not contain a <b>dir</b> token
    <tr><td><var>xs</var>・<b>file</b> <var>x</var> <td> ⇒ <td> <b>drive</b> <var>x</var> – if  <var>x</var> :: drive-letter and <var>xs</var> does not contain a <b>dir</b> token
  </table>

  <p>Drive letter detection must not be applied to URLs that have a scheme that is not <code>file</code>. It may be applied to schemeless URLs in contexts where file URLs are expected.
</section>


<section><h2>Host processing</h2>

  <div class=todo>
  <ul>
    <li>Err on forbidden host codepoints excluding <code>%</code>
    <li>Percent decode
    <li>Puny decode
    <li>Apply IDNA/ Nameprep normalisation
    <li>Detect IPv4 addresses
    <li>Err on forbidden host codepoints
  </ul>
  </div>

  <h4>IPv6 Address</h4>
  <p>
    An IPv6 address-string <!--consists of a sequence of items, separated by
    <code>:</code> or <code>::</code>, the items being hexadecimal except for
    the last itme, which may consist of four decimal numbers separated by
    <code>.</code> as follows:-->
    is a string representation of a number <var>n</var> &lt; 2<sup>128</sup>. 
    It is accurately described by the production rule <var>IPv6address</var>
    in the <a href=https://tools.ietf.org/html/rfc3986#section-3.2.2>Host</a>
    section of RFC3986. 

  <h4>IPv4 Address</h4>
  <p>
    An IPv4 address-string consists of one up to four dot-separated numbers with an optional trailing dot. The numbers may use decimal, octal or hexadecimal notation, as follows:

  <table>
    <tr><td>ip4-address <td> ::= <td> ip4num [<code>.</code> ip4num [<code>.</code> ip4num [<code>.</code> ip4num ] ] ] [<code>.</code>]
    <tr><td>ip4num <td> ::= <td> ip4dec | ip4octal | ip4hex
    <tr><td>ip4dec <td> ::= <td> <code>0</code> | digit_nonzero digit*
    <tr><td>ip4octal <td> ::= <td> <code>0</code> octaldigit*
    <tr><td>ip4hex <td> ::= <td> (<code>0x</code> | <code>0X</code>) hexdigit*
  </table>

  <p>Note that <code>0x</code> is parsed as a hexadecimal number. (It will be interpreted as 0).
</section>


<section><h2>Reference Resolution</h2>

  <p>
    This section defines a reference resolution operation that is analogous,
    but not equal to the algorithm that is described in the chapter
    <a href="https://tools.ietf.org/html/rfc3986#section-5">Reference
    Resolution</a> of RFC 3986. Likewise, it is analogous, but not equal to the
    &ldquo;basic URL parser&rdquo; that is described in the section
    <a href="https://url.spec.whatwg.org/#url-parsing">URL parsing</a> of the
    WhatWG standard. The operations shall later be used to define a
    parse-resolve-and-normalise operation that is compatible with the WhatWG
    standard.

  <p>
    Reference Resolution as defined in this section does not involve
    URL-strings. It solely operates on URLs as defined in the section
    <a href=#model>URL Model</a> above. In contrast with the previously
    mentioned sections in RFC 3986 and in the WhatWG standard, it does not do
    additional normalisation, which is relegated to the section
    <a href=#normalisation>Normalisation</a> instead.

  <h4>The Order of an URL</h4>
  <p>
    A property that is particularily useful is the <i>order</i> of an URL.
    Colloquially, the order is the type of the first token of an URL. The order
    may be used as an argument to specify various prefixes of an URL.

  <p class=-line>
    The <dfn>order</dfn> of an URL (<b class=fn>ord</b> <var>url</var>) is
    defined to be:
  <ul>
    <li>
      <b>fragment</b> if <var>url</var> is the empty URL.
    <li>
      The type of its first token otherwise.
  </ul>

  <p class=-line>
    The <dfn>order-limited prefix</dfn>
    (<var>url</var> <b class=-op>upto</b> <var>order</var>)
    is defined to be <br>
    the <em>shortest</em> prefix of <var>url</var> that contains:
    <ul>
      <li>
        all tokens of <em>url</em> with a type strictly smaller than
        <var>order</var> and
      <li>
        all <b>dir</b> tokens with a type weakly smaller than
        <var>order</var>.
  </ul>


  <h3>The Goto operations</h3>
  <p>
    Based on the order and the order-limited prefix one can define
     &ldquo;goto&rdquo; and &ldquo;nonstrict goto&rdquo; operations that are
    analogous to the &ldquo;merge&rdquo; operation and its nonstrict
    counterpart defined in section
    <a href="https://tools.ietf.org/html/rfc3986#section-5.2.2">Transform
    References</a> of RFC 3986.

  <p>
    I have chosen to rename &ldquo;merge&rdquo; to &ldquo;goto&rdquo; to avert
    the risk of incorrect assumptions about commutativity. 
    The operations are not commutative, but they are associative.

    <h4>Goto</h4>
    <p>
      The <dfn>goto</dfn> operation (<var>url<sub>1</sub></var> goto <var>url<sub>2</sub></var>) is defined to return <br>
      the <em>shortest</em> URL that has <var>url<sub>1</sub></var> upto (ord <var>url<sub>2</sub></var>) as a prefix and <var>url<sub>2</sub></var> as a postfix.

    <h4>Non-Strict Goto</h4>
    <p class=-line>
      The <dfn>non-strict goto</dfn>
      (<var>url<sub>1</sub></var> ~goto <var>url<sub>2</sub></var>) is defined
      to be<br>
      (<var>url<sub>1</sub></var> goto <var>url<sub>2</var>') where
      <var>url<sub>2</var>' is <var>url<sub>2</var> with the <b>scheme</b>
      token removed if it case-insensitively compares equal to the <b>scheme</b>
      token of <em>url<sub>1</sub></em>, or <em>url<sub>2</sub></em>
      otherwise.<br><br>

  <h4>Properties of the Goto operations</h4>

  <ul>
    <li>ord (url1 goto url2) is the least type of {ord url1, ord url2}.
    <li>(url1 goto url2) goto url3 = url1 goto (url2 goto url3).
    <li>ε goto url2 = url2.
    <li>url1 goto ε = url1 is <b>not</b> true in general (the fragment is dropped).
    <li>similar for ~goto.
    <li>url2 is a postfix of (url1 goto url2) but not necessarily of (url1 goto&rsquo; url2).
  </ul>

  <h3>Resolution</h3>
  <p>
    Finally, reference resolution can be defined.

  <h4>Pre-Resolution</h4>
    <p class=-line>
      The <dfn>pre-resolution</dfn> of <em>url1</em> against <em>url2</em> is
      defined to be:
    <ol>
      <li><var>url2</var> ~goto <var>url1</var> — if <var>url2</var> is a
        <i>base URL</i> or if <var>url1</var> has a <b>fragment</b> token.
      <li>
        <var>url1</var> otherwise. 
  </ol>

  <p>
    The condition in 1. is necessary to emulate the behaviour of the
    parse-and-resolve algorithm of the WhatWG standard. The definition of a 
    <i>base URL</i> in this specification, is a negation of the special 
    <em>cannot-be-a-base-url</em> status in the WhatWG standard. In their
    parse-and-resolve algorithm, such <em>cannot-be-a-base-url</em> URLs are
    implicitly ignored unless the input constitutes an URL that consists of a
    <b>fragment</b> token only. 

  <h4>Resolution</h4>
    <p>
      The <dfn>resolution</dfn> of <var>url1</var> against <var>url2</var> is
      defined to be the <i>pre-resolution</i> of <var>url1</var> against
      <var>url2</var>, if its order is <b>scheme</b> or <b>fragment</b>.
      Otherwise resolution fails. 


  <div class=todo>
    This needs a few small tweaks still to align with the URL constructor.</div>

  <p>
    There is an additional operation on URLs called <em>force</em> that 
    it is used as an error-recovery measure for special URLs that have an empty
    authority. Colloqually, this operation promotes the first <b>dir</b> 
    or <b>file</b> token to an authority. To do so, it must invoke the 
    authority parser on the value of such <b>dir</b> or <b>file</b> token.

  <h4 id="forced-resolution">Forced Resolution</h4>
  <p>
    The result of <b>forcing</b> an URL <em>url1</em>  is defined to be:
  <ul>
    <li><em>url1</em> if <em>url1</em> has a substantial <b>authority</b>
    <li>&hellip;
  </ul>
</section>


<section><h2>Equivalences and Normalisation</h2>
  <p>
    This section is analogous to the section
    <a href="https://tools.ietf.org/html/rfc3986#section-6.2">Normalization and 
    Comparison</a> of RFC 3986. The RFC however, does not <em>prescribe</em> a
    particular normal form. The WhatWG standard, does, but it does so 
    implicitly. 

<div class=todo>
  (Equivalence relation)<br>
  Normal form obtained by directing the rules ltr
</div>

<h4>Path Segment Normalization</h4>

<table>
  <tr><td><b>dir</b>  <var>x</var> <td> ≈ <td>ε <td>–<td> if <var>x</var> :: <i>dot</i></td>
  <tr><td><b>file</b> <var>x</var> <td> ≈ <td>ε <td>–<td> if <var>x</var> :: <i>dot</i></td>

  <tr><td><b>dir</b>  <var>x</var>・<b>dir</b> <var>y</var> <td> ≈ <td> ε                                
    <td> – <td> if <var>y</var> :: <i>dots</i> and <strong>not</strong> <var>x</var> :: <i>dots</i>
  <tr><td><b>dir</b>  <var>x</var>・<b>file</b> <var>y</var> <td> ≈ <td> ε                                
    <td> – <td> if <var>y</var> :: <i>dots</i> and <strong>not</strong> <var>x</var> :: <i>dots</i>

  <tr><td><b>path-root</b> <var>x</var>・<b>dir</b> <var>y</var>  <td> ≈ <td><b>path-root</b> <var>x</var>
    <td> – <td> if <var>y</var> :: <i>dots</i>
  <tr><td><b>path-root</b> <var>x</var>・<b>file</b> <var>y</var> <td> ≈ <td><b>path-root</b> <var>x</var>
    <td> – <td> if <var>y</var> :: <i>dots</i>

  <tr class=-inbetween><td colspan=10>where,
  <tr><td><i>dot</i> <td> ::= <td> <code>%2e</code> | <code>%2E</code>
  <tr><td><i>dots</i> <td> ::= <td> <i>dot</i> <i>dot</i>
</table>

<h4 id="authority-normalisation">Authority normalisation</h3>
  <table>
    <tr><td><b>username</b> ε・<b>password</b> ε <td> ≈ <td>ε
    <tr><td><b>password</b> ε <td> ≈ <td>ε
    <tr><td><b>port</b> ε <td> ≈ <td>ε
  </table>

<h4 id="scheme-dependent-normalisation">Scheme-based Normalisation</h4>
  <table>
    <tr><td><b>scheme</b> <code>file</code> ・<b>authority</b> (<b>host</b> <code>localhost</code>)           <td> ≈ <td> <b>scheme</b> <code>file</code> ・<b>authority</b> (<b>host</b> ε)
    <tr><td><b>scheme</b> <code>http</code> ・<b>authority</b> (<var>xs</var>・<b>port</b> <code>80</code>)  <td> ≈ <td> <b>scheme</b> <code>http</code> ・<b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>ws</code>   ・<b>authority</b> (<var>xs</var>・<b>port</b> <code>80</code>)  <td> ≈ <td> <b>scheme</b> <code>ws</code>   ・<b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>ftp</code>  ・<b>authority</b> (<var>xs</var>・<b>port</b> <code>21</code>)  <td> ≈ <td> <b>scheme</b> <code>ftp</code>  ・<b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>wss</code>  ・<b>authority</b> (<var>xs</var>・<b>port</b> <code>443</code>) <td> ≈ <td> <b>scheme</b> <code>wss</code>  ・<b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>https</code>・<b>authority</b> (<var>xs</var>・<b>port</b> <code>443</code>) <td> ≈ <td> <b>scheme</b> <code>https</code>・<b>authority</b> <var>xs</var>
  </table>
</section>

<h2 id="validation">Validation</h2>

<h2 id="percent-coding">Percent Coding</h2>

<h2 id="printing">Printing</h2>

<p>Printing is the process of converting an URL to an URL-string.

<p>To obtain an URL-string for a given URL <var>url1</var> proceed as follows.

<ul>
  <li>Let <var>url2</var> be <var>url1</var>, percent encoded.
  <li>Let output be the empty string, then, for each of the tokens (<em>type</em>, <em>value</em>) of <em>url2</em> in order, convert the token to a string according to the following table and append it to the output.
</ul>

<table><thead><tr>
  <th><b>scheme</b> <th><b>authority</b> <th><b>drive</b> <th><b>path-root</b> <th><b>dir</b> <th><b>file</b> <th><b>query</b> <th><b>fragment</b>
<tbody><tr>
  <td><em>value</em><code>:</code>
  <td><code>//</code>print_auth(<em>value</em>)
  <td><code>/</code><em>value</em>
  <td><code>/</code>
  <td><em>value</em><code>/</code>
  <td><em>value</em>
  <td><code>?</code><em>value</em>
  <td><code>#</code><em>value</em>
</table>

</body>
</html>