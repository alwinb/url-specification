<!DOCTYPE html>
<html lang="en" class="-debug">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>URL Specification</title>
  <link rel="stylesheet" href="style/base.css">
  <link rel="stylesheet" href="style/style.css">
  <script src="scripts/pct.js"></script>
  <script>
    const log = console.log.bind (console)
    

    const $ = (name, ...subs) => {
      const r = document.createElement (name)
      r.append (...subs)
      return r
    }

    function buildTOC (doc = document) {
      const heads = doc.getElementsByTagName ('H2')
      const toc = doc.getElementById ('toc')
      for (let h of heads)
        if (!h.classList.contains('-toc-exclude'))
        toc.append ($('li', h.innerText))
    }

    function buildIndex (doc = document) {
      const defs = doc.getElementsByTagName ('DFN')
      const index = { }
      for (let def of defs) {
        let block = getDefScope (def)
        let text = def.innerText.replace(/\s+/, ' ')
        index [def.innerText] = { text, def, block }
      }
      log (index)
      return index
    }
    
  function getDefScope (elem) {
    let block = elem, para = null
    while (block) {
      block = block.parentNode
      para  = block.tagName === 'P' ? block : para
      if (block.classList.contains('dfn-scope')) break
      if (block.tagName === 'BODY') block = null
    }
    return block || para
  }
    


  window.addEventListener('DOMContentLoaded', $=> {
    const index = buildIndex ()
    const toolsDiv = document.getElementById ('tools')
    
    const onover = evt => {
      let elem = evt.target
      //toolsDiv.append ('over ')
      
      if (elem.tagName in {'I':1, 'B':1} && !elem.classList.contains('noindex')) {
        const text = evt.target.innerText.replace(/\s+/, ' ')
        let entry 
        if ((entry = index[text].block)) {
          const block = getDefScope (elem)
          log (entry)
          if (entry.block === block) return
          const tip = entry.cloneNode(true)
          toolsDiv.innerHTML =''
          toolsDiv.append (tip)
        }
      else {
        toolsDiv.innerHTML =''
      }
      }
      else {
        toolsDiv.innerHTML =''
      }
    }
    document.body.addEventListener ('mouseover', onover)
  })

  </script>
</head>
<body>
  
<div id=tools>
</div>

<article>
<h1>URL Specification</h1>

<section>
  <p>
    This document provides a concise formal specification of
    <span class=url>URL</span>s and the language of
    <span class=url>URL</span>s. It is a <em>reverse specification</em> of the
    <a href="https://url.spec.whatwg.org/"><abbr class=-caps>WHATWG-URL</abbr>
      standard</a>.
  <p class=-inbetween>
    The goals of this document are,
  <ul class=-prose>
    <li>
      To provide a modular, concise formal specification that is compatible
      with, and covers all of the <a href="https://url.spec.whatwg.org/"
      ><abbr class=-caps>WHATWG-URL</abbr> standard</a> with the one exception
      being their specification of the web <abbr class=-caps>API</abbr>'s
      setters and the url-encoded form format.
    <li>
      To define a general model for <span class=url>URL</span>s that can
      express relative references and to define reference resolution by means
      of a number of elementary operations, in such a way that the end result
      is compatible with the
      <abbr class=-caps>WHATWG URL</abbr> standard.
    <li>
      To enable and support efforts <em>towards</em> a single
      <strong><em>Unified <span class=url>URL</span> Standard</em></strong>
      that includes a normative specification of <span class=url>URL</span>
      handling by web browsers and that resolves the incompatibilities between
      <a href="https://tools.ietf.org/html/rfc3986"><abbr class=-caps>RFC</abbr> 3986</a>,
      <a href="https://tools.ietf.org/html/rfc3987"><abbr class=-caps>RFC</abbr> 3987</a> and the
      <a href="https://url.spec.whatwg.org/"
      ><abbr class=-caps>WHATWG-URL</abbr> standard</a>.
    <li>
      To provide the authors of the <abbr class=-caps>WHATWG</abbr> standard
      with a support document that they can use as a reference in their efforts
      to standardise the behaviour of web browsers.
  </ul>
</section>

<section><h2 class=-toc-exclude>Status of this document</h2>
  <ul>
    <li>
      This is version 0.2.0 of the specification. This is a development 
      version. 
    <li>
      The versioning scheme is specified by
      <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.
    <li>
      This document is licensed under a
      <a href="https://creativecommons.org/licenses/by/4.0/">
      Creative Commons - <abbr class=-caps>CC BY</abbr> 4.0</a> license. 
  </ul>
</section>

<section><h2 class=-toc-exclude>Structure of this document</h2>
  <p>
    As of this writing, this document has a compact format that is focused
    specifically on the definition and specification of <span
     class=url>URL</span>s and operations on <span class=url>URL</span>s. 
    It does not include a discussion of their history or their use in
    various contexts. It does contain valuable non-normative references to
    <a href="https://tools.ietf.org/html/rfc3986"><abbr class=-caps>RFC</abbr> 3986</a> that can be
    followed for additional information about the concepts involved.

  <p class=-inbetween>
    The sections are laid out as follows.
  <ul id=toc>
    <!-- auto generated -->
  </ul>
  <script>
    window.addEventListener('DOMContentLoaded', $=> buildTOC())
  </script>
</section>

<section><h2>Preliminaries</h2>

  <p>
    This section introduces basic concepts and notational conventions upon 
    which the rest of the specification is built. 

  <h4>Sequences</h4>
  <div class="dfn-scope +br">
  <p>
    This specification uses an algebraic notation for <dfn>sequence</dfn>s that
    makes no distinction between one-element sequences and their first element. 
    It uses the following notation:
  <ul class=-inbetween>
    <li>
      The empty sequence is denoted by ε. 
    <li>
      The concatenation of two sequences <var>S</var> and <var>T</var> is
      denoted by <var>S</var>・<var>T</var>. 
  </ul>
  <p>
    Parentheses are used for disambiguation and as visual aides. Paired 
    parentheses are not part of a sequence-constructing operation. 
  </div>    

  <div class="dfn-scope +br">
  <!-- add to dfn index -->
  <div style=display:none><dfn>value</dfn><dfn>type</dfn></div>
  <h4>Tokens</h4>
  <p>
    The word <dfn>token</dfn> is used throughout this specification to mean a
    tagged value, denoted by (<var>type</var> <var>value</var>), where
    <var>type</var> is taken from a predefined set <dfn>token-type</dfn>s.
  </div>
  <p>
    Both <i>tag</i> constants and their corresponding
    <i class=common>token</i>-constructing operator are typeset in boldface.
    For example, <b>scheme</b> denotes a <i>token-type</i>, whilst
    (<b>scheme</b> <var>value</var>) denotes a <i>token</i>.
  <br>
    Again, parentheses are used to disambiguate and as visual aides. 
    They are not part of the <i class=common>token</i>-constructing operator. 

  <p>
    The <i class=common>value</i> of a <i class=common>token</i> may be a
    <i class=common>sequence</i> of
    <i class=common>token</i>s itself, in which case the
    <i class=common>token</i> may be referred
    to as a <dfn>compound-token</dfn> for clarity.
    <!--and the tokens present in its value may be referred to as
    <dfn>sub-token</dfn>s.-->
  <p>
    When a collection of <i class=common>token</i>s contains exactly one
    <i class=common>token</i> (<var>tag</var> <var>value</var>) for a given
    <i class=common>tag</i>, then
    the <i class=common>tag</i> may be used to refer to its
    <i class=common>value</i> directly. For
    example, given a <i class=common>sequence</i> of <i class=common>token</i>s
    S := (<b class=noindex>dir</b> <var>x</var>・<b class=noindex>file</b> <var>y</var>・<b class=noindex>query</b> 
    <var>z</var>), the prase
    &ldquo;the <b class=noindex>query</b> of S&rdquo; identifies the
    <i class=common>value</i> <var>z</var> whereas the phrase &ldquo;the
    <b class=noindex>query</b> <i class=common>token</i> of
    S&rdquo; identifies (<b class=noindex>query</b> <var>z</var>).

  <h4>Strings and Code-Points</h4>
    <p class=-br>
      For the purpose of this specification,
    <ul class=dfn-scope>
      <li>
        A <dfn>string</dfn> is a <i class=common>sequence</i> of
        <i>character</i>s.
      <li>
        A <dfn>character</dfn> is a single
        <a href="https://www.unicode.org/versions/latest/">Unicode</a>
        <i>code point</i>.
      <li>
        A <dfn>code point</dfn>, is a natural number <var>n</var> ≤ 1114111.
      <li>
        The <dfn>empty string</dfn> is a <i class=common>sequence</i> of zero
        code points. It is denoted by ε. 
    </ul>
    <p>
      Code points are denoted by a number in <em>hexadecimal</em> notation
      preceded by <b class=noindex>u+</b> in boldface. In addition, code points
      that correspond to printable <abbr class=-caps>ASCII</abbr> characters are
      often denoted by their corresponding glyph, typeset in monospace on a
      screened background.
      For example, <b>u+41</b> and <code>A</code> denote the same
      code point. Strings that contain only printable
      <abbr class=-caps>ASCII</abbr> characters are often denoted as a 
      connected sequence of glyphs, typeset likewise.
    <p>
      The printable <abbr class=-caps>ASCII</abbr> characters are codepoints in
      the range <b>u+20</b> to <b>u+7E</b>, inclusive. Note that this
      includes the space character <b>u+20</b>.


  <h4>Character Sets</h4>
  <p>
    A <dfn>character range</dfn> is the largest set of characters that includes
    a given least character <var>c</var> and a greatest character <var>d</var>.
    Such a character range is denoted by { <var>c</var>–<var>d</var> }.
    Furthermore, the union of e.g. { <var>a</var>–<var>b</var> }
    and { <var>c</var>–<var>d</var> }, is denoted by
    { <var>a</var>–<var>b</var>, <var>c</var>–<var>d</var> }, and this
    notation is generalised to <var>n</var>-ary unions. Character sets that are 
    used throughout this specification are defined below: 

  <table class=grammar>
    <tr><td>        any <td> := <td> { <b>u+0</b>–<b>u+10FFFF</b> }
    <tr><td> c0-control <td> := <td> { <b>u+0</b>–<b>u+1F</b> }
    <tr><td> printable-<abbr class=-caps>ASCII</abbr><td> := <td>
      { <b>u+20</b>–<b>u+7E</b> } — i.e. { <code><span style=width:1ch;display:inline-block;padding:0> </span></code>–<code>~</code> }
    <tr><td> octaldigit <td> := <td> { <code>0</code>–<code>7</code> }
    <tr><td>      digit <td> := <td> { <code>0</code>–<code>9</code> }
    <tr><td>   hexdigit <td> := <td> { <code>0</code>–<code>9</code>, 
      <code>A</code>–<code>F</code>,  <code>a</code>–<code>f</code> }
    <tr><td> digit-nonzero <td> := <td> { <code>1</code>–<code>9</code> }
    <tr><td>      alpha <td> := <td> { <code>A</code>–<code>Z</code>, 
      <code>a</code>–<code>z</code> }
    <tr><td> c1-control <td> := <td> { <b>u+80</b>–<b>u+9F</b> }
    <tr><td>    latin-1 <td> := <td> { <b>u+A0</b>–<b>u+FF</b> }
    <tr><td>  surrogate <td> := <td> { <b>u+D800</b>–<b>u+DFFF</b> }


  </table>

  <h4>Grammars</h4>
  <p>
    The notation <var>name</var> ::= <var>expression</var> is used to define
    the production rules of a grammar, where the <i>expression</i> uses
    square brackets ( [ _ ] ) <strong>for optional rules</strong>, a postfix
    star ( * ) for zero-or-more, a postfix plus ( + ) for one-or-more, an infix
    vertical line ( | ) for alternatives, monospaced type for literal
    <i class=common>string</i>s
    and an epsilon ( ε ) for the empty string. Parentheses are used for 
    grouping and disambiguation. 

  <h4>Pattern Matching</h4>
  <p>
    The shorthand notation <var>string</var> :: <var>rule</var> is used to
    express that a <i class=common>string</i> <var>string</var> can be
    generated by the production rule <var>rule</var> of a given grammar.
    <br>Likewise, the notation 
    <var>string</var> :: <var>expression</var> is used to express that 
    <var>string</var> can be generated by <var>expression</var>.

</section>


<section><h2>URL Model</h2>
<p>
  An <i class=url>URL</i> is a special kind of ordered list that is
  subject to a number of additional constraints. The ordering of the list is
  analogous to the hierarchical syntax of an URI as described in
  <a href="https://tools.ietf.org/html/rfc3986#section-1.2.3">Hierarchical
  Identifiers</a> in <abbr class=-caps>RFC</abbr> 3986.
<p>
  It is important to stress the distinction between an
  <i class=url>URL</i> and an <i><span class=url>URL</span>-string</i>.
<br>
  <span class=dfn-scope>
    An <i class=url>URL</i> is a <em>structure</em>, indeed a special
    kind of ordered list, whereas an
    <dfn><span class=url>URL</span>-string</dfn> is a
    special kind of <i>string</i> that <em>represents</em> an <span
   class=-caps>URL</span></span>. Conversions between <i class=url>URL</i>s
  and <i><span class=url>URL</span>-strings</i> are described in the sections on
  <a href="#parsing">parsing</a> and <a href="#printing">printing</a>.

  <h4>URL</h4>
    <p>
      An <dfn><i class=url>URL</i></dfn> is a <i>sequence</i> of
      <i>token</i>s that occur in ascending order by <i>token-type</i>,
      where <i>token-type</i> is taken from
      the ordered set: 
    <p class="-center">
      <b>scheme</b> &lt; <b>authority</b> &lt; <b>drive</b>
      &lt; <b>path-root</b> &lt; <b>dir</b> &lt; <b>file</b>
      &lt; <b>query</b> &lt; <b>fragment</b>.

    <p>
      <i class=url>URL</i>s are subject to the following constraints:
    <ul>
      <li>
        An <i class=url>URL</i> contains at most one
        <i class=common>token</i> per <i class=common>type</i>, 
        except for <b>dir</b> <i class=common>token</i>s, of which it may have
        any finite amount.
      <li>
        If an <i class=url>URL</i> has an <b>authority</b> or a
        <b>drive</b> <i class=common>token</i>, and it has a <b>dir</b> or a
        <b>file</b> token, then it also has a <b>path-root</b>
        <i class=common>token</i>.
    </ul>
    <ul>
      <li class=dfn-scope>
        The <dfn><b>scheme</b></dfn> of an <i class=url>URL</i>,
        if present, is a
        <i class=common>string</i> <span class=-nowrap><var>scheme</var> :: alpha (alpha | digit | 
        <code>+</code> | <code>-</code> | <code>.</code>)*</span>
      <li class=dfn-scope>
        The <dfn><b>authority</b></dfn> of an <i class=url>URL</i>,
        if present, is
        an <i>Authority</i> — to be defined below.
      <li class=dfn-scope>
        The <dfn><b>path-root</b></dfn> of an <i class=url>URL</i>,
        if present, is the string <code>/</code>. 
      <li class=dfn-scope>
        The <dfn><b>drive</b></dfn> of an <i class=url>URL</i>,
        if present, is a
        <i class=common>string</i> <span class=-nowrap><var>drive</var> ::
          alpha (<code>:</code> | <code>|</code>)</span>
      <li class=dfn-scope>
        The <dfn><b>file</b></dfn> of an <i class=url>URL</i>,
        if present, is a nonempty string.
      <li>
        For all other tokens present, the tokens&rsquo; values are
        <i class=common>string</i>s.
      </ul>
      <ul style=display:none>
        <li class=dfn-scope>
          A <dfn><b>dir</b></dfn> token, is a token (<b>dir</b> <var>name</var>)
          where <var>name</var> is a string.
        <li class=dfn-scope>
          The <dfn><b>query</b></dfn> of an <i class=url>URL</i>,
          if present, is a string.
        <li class=dfn-scope>
          The <dfn><b>fragment</b></dfn> of an <i class=url>URL</i>,
          if present, is a string.
      </ul>
    </ul>


    <div class="dfn-scope +br">
    <h4>Base-URL</h4>
    <p>
      A <dfn>base-<span class=url>URL</span></dfn> is an <i>
      <i class=url>URL</i></i> that has a <i><b>scheme</b></i>
      and that has in addition, an <i><b>authority</b></i> or a
      <i><b>path-root</b></i>.
    </div>


    <div class="dfn-scope +br">
    <h4>Web-URL</h4>
      <p class=-br>
        <span style=display:none><dfn>special</dfn></span>
        A <dfn>web-<span class=url>URL</span></dfn> is an
        <i class=url>URL</i> that has a <i>web-<b>scheme</b></i>.
        <!-- A <dfn>non-special <span class=url>URL</span></dfn> is an
        <span class=url>URL</span> that is not <i>special</i>. -->
        A <dfn>web-scheme</dfn> is a <i class=common>string</i>
        <var>scheme</var> such that
        <span class=-nowrap>lowercase (<var>scheme</var>) <td>::<td>
            <code>http</code> | <code>https</code> | <code>ws</code> | 
            <code>wss</code> | <code>ftp</code>.
    </div>

    <div class="dfn-scope +br">
    <h4>File-URL</h4>
      <p>
        A <dfn>file-<span class=url>URL</span></dfn> is an
        <i class=url>URL</i> that has a <i>file-<b>scheme</b></i>.
        A <dfn>file-<b>scheme</b></dfn> is a <i class=common>string</i>
        <var>scheme</var> such that
        <span class=-nowrap>lowercase (<var>scheme</var>) :: <code>file</code>. 
    </div>



    <div class=dfn-scope>
    <h4>Authority</h4>
    <p>
      An <dfn>Authority</dfn> is a sequence of tokens ordered by their type, 
      taken from the ordered set:

    <p class="-center">
      <b>username</b> &lt; <b>password</b> &lt; <b>host</b> &lt; <b>port</b>.

    <p class=-br>
      Authorities are subject to the following constraints:
    </div>

    <ul>
      <li>
        Authorities contain at most one <i class=common>token</i> per
        <i class=common>type</i>.
      <li>
        If an Authority has a <b>password</b> <i class=common>token</i> then it
        also has a <b>username</b> <i class=common>token</i>.
      <li>
        If an Authority has a <b>username</b> or a <b>port</b>
        <i class=common>token</i> then it also has a <b>host</b>
        <i class=common>token</i>.
    </ul>

    <p class=-br>
      The <i class=common>token</i>s of an Authority are subject to the
      following conditions:
    <ul>
      <li class=dfn-scope>
        The <dfn><b>host</b></dfn> of an Authority is a <i>Host</i> — to be 
        defined below.
      <li class=dfn-scope>
        The <dfn><b>port</b></dfn> of an Authority, if present, is either the
        empty string ε, or a natural number <var>n</var> &lt; 2<sup>16</sup>.
      <li class=dfn-scope>
        For all other <i class=common>token</i>s present, the
        <i class=common>token</i>s' <i class=common>value</i>s
        are <i class=common>string</i>s.
    </ul>


  <div class=dfn-scope>
    <h4>Host</h4>
    <p class=-br>
      A <dfn>Host</dfn> is either
    <ul>
      <li>
        An ipv6-address,
      <li>
        An opaque-host, which is a <i class=common>string</i>
        <var>host</var> :: <i class=rule>opaque-host</i>
      <li>
        An ipv4-address, or
      <li>
        A domain-name.
    </ul>
  </div>

  <h3>Additional Constraints</h3>
  <p class=-br>
    If an <i class=url>URL</i> <var>url</var> has a <b>scheme</b> then 
    it is subject to two additional constraints:
    <ul>
  <li>
    If <var>url</var> is not a <i>file-<span class=url>URL</span></i> 
    then it must not have a <b>drive</b> <i class=common>token</i>.
  <li>
    If <var>url</var> <strong>is</strong> a 
    <i>file-<span class=url>URL</span></i>, and it has an <b>authority</b>,
    then the authority must not contain a <b>username</b>, <b>password</b> or
    <b>port</b>.
</ul>
</section>

<section><h2>Parsing</h2>
  <!--<ul>
    <li>An URL-string is a string that represents an URL.
    <li>There are strings that are not URL strings.
    <li>It is possible for a single URL to be represented by more than one URL string.
    <li>URL strings are further divided into valid URL strings and invalid URL strings.
  </ul>-->

  <p>Parsing is stratified into the following phases:

  <ol class=-inbetween>
    <li>Preprocessing.
    <li> Selecting the parser mode.
    <li> Parsing.
    <li> Detecting drive letters.
    <li> Decoding and parsing the host.
  </ol>

  <h3>Preprocessing</h3>
  <p class=-br>
    Before parsing, preprocess the input string <var>input</var> as follows:
  <ul>
    <li>
      Remove all leading and trailing <i>c0-control</i> and <b>u+20</b> 
      (space) characters from <var>input</var>.
    <li>
      Remove all <b>u+9</b> (tab), <b>u+A</b> (line-feed) and <b>u+D</b>
      (carriage-return) characters from <var>input</var>.
  </ul>

  <h3>Parser modes</h3>

  <p>
    The parser mode can be determined by &lsquo;sniffing&rsquo; a scheme from 
    the input before parsing. This can be done in a multiple of ways. 
    The mode selection can be implemented within the parser, by adding a bit of
    additional logic after a scheme rule. For this specification however,
    it is useful to specify it as a separate step, so that the grammar can be
    presented as a whole. 

  <p class=-inbetween>
    Define the following rules.

  <table class=grammar>
    <tr><td>special-scheme <td> ::= <td> <code>http</code> | <code>https</code> | <code>ws</code> | <code>wss</code> | <code>ftp</code> | <code>file</code>
    <tr><td>is-special <td> ::= <td> special-scheme <code>:</code> any*
    <tr><td>has-scheme <td> ::= <td> alpha (alpha | digit | <code>+</code> | <code>-</code> | <code>.</code>)*<code>:</code> any*
  </table>

  <p class=-inbetween>The mode can be selected as follows.

  <ul>
    <li>Let <var>magic</var> be the first <var>n</var> characters of <var>input</var>, with <var>n</var> being min (6, input.length).
    <li>Set the parser mode to <b>special</b> if (lowercase <var>magic</var>) :: is-special.
    <li>Otherwise if the fallback scheme is <b>special</b> and <var>input</var> :: has-scheme, then set the parse mode to non-special.
  </ul>

  <p>
    The grammar is parameterised by the parser mode. There are three parser 
    modes: <b>default</b>, <b>web</b> and <b>file</b>.

    <!-- In <b>special</b> mode, the s subscripted rules must be used instead of their unsubscripted counterparts, whenever available. -->

  <h4>URL Grammar</h4>
    <table class=grammar>
      <!-- <tr><td>url <td> ::= <td> [ scheme <code>:</code> ] [ s s authority ] [ path-root ] (dir s)* [ file ] [ <code>?</code> query ] [ <code>#</code> fragment ] -->
      <tr><td>url <td> ::= <td> [ scheme <code>:</code> ] (auth-path | path) [ <code>?</code> query ] [ <code>#</code> fragment ]
      <tr><td>auth-path <td> ::= <td> s s authority [ path-root [ dir s ]* [ file ] ]
      <tr><td>path <td> ::= <td> [ path-root ] path-rel

      <tr class=-inbetween>
        <td colspan=3>Modified <i>auth-path</i> rule for <i>file-<span class=url>URL</span></i>s:
      <tr>
        <td>auth-path<sub>F</sub> <td> ::= <td> ([ s [s] ] drive) | s s host) [ path-root [ dir s ]* [ file ] ]

      <tr class=-inbetween>
        <td colspan=3>This refers to the following rules:

      <tr><td>scheme <td> ::= <td> alpha (alpha | digit | <code>+</code> | <code>-</code> | <code>.</code>)*
      <tr><td>authority <td> — <td> shall be defined in the next subsection,
      <tr><td>host <td> — <td> shall be defined in the next subsection,
      <tr><td>drive <td> ::= <td> alpha (<code>:</code> | <code>|</code>)
      <tr><td>path-root <td> ::= <td> s
      <tr><td>dir <td> ::= <td> pchar*
      <tr><td>file <td> ::= <td> pchar+
      <tr><td>query <td> ::= <td> qchar*
      <tr><td>fragment <td> ::= <td> any*

      <tr class=-inbetween>
        <td colspan=3>These rules are based on the following character sets:
      <tr><td>s <td> ::= <td> { <code>/</code> }
      <tr><td>pchar <td> := <td> any \ { <code>/</code>, <code>#</code>, <code>?</code> }
      <tr><td>qchar <td> := <td> any \ { <code>#</code> }

      <tr class=-inbetween>
        <td colspan=3>The character sets are modified for <i>file-<span class=url>URL</span></i>s and <i>web-<span class=url>URL</span></i>s:
      <tr><td>s<sub>S</sub> <td> ::= <td> { <code>/</code>, <code>\</code> }
      <tr><td>pchar<sub>S</sub> <td> := <td> any \ { <code>/</code>, <code>\</code>, <code>#</code>, <code>?</code> }
    </table>

  <h4>Authority Grammar</h4>
    <table class=grammar>
      <tr><td>authority <td> ::= <td> ε  |  [ credentials <code>@</code> ] host [ <code>:</code> port ]
      <tr><td>credentials <td> ::= <td> username [ <code>:</code> password ]

      <tr class=-inbetween><td colspan=3>This refers to the following rules:

      <tr><td>username <td> ::= <td> uchar*
      <tr><td>password <td> ::= <td> pchar*
      <tr><td>host <td> ::= <td> <code>[</code> ip6-address <code>]</code> | opaque-host
      <tr><td>opaque-host <td> ::= <td> hchar+
      <tr><td>port <td> ::= <td> ε | digit+

      <tr class=-inbetween><td colspan=3>These rules are based on the following character sets:

      <tr><td>uchar <td> := <td> pchar \ { <code>:</code> }
      <!-- <tr><td>hchar <td> := <td> pchar \ { <code>@</code>, <code>:</code> } -->
      <tr><td>hchar <td> := <td> any \ { <b>u+0</b>, <b>u+9</b>, <b>u+A</b>, <b>u+D</b>, <code><span style=display:inline-block;width:1ch> </span></code>, <code>#</code>, <code>/</code>, <code>:</code>, <code>&lt;</code>, <code>&gt;</code>, <code>?</code>, <code>@</code>, <code>[</code>, <code>\</code>, <code>]</code>, <code>^</code> }
      <!-- <tr><td>portchar <td> := <td> pchar \ { <code>@</code> } -->
    </table>

    <div class=todo>
    <ul>
      <li>Host processing
      <li>Evaluating the port
    </ul>
  </div>

  <h4>IPv6 Address</h4>
  <p>
    An IPv6 address-string <!--consists of a sequence of items, separated by
    <code>:</code> or <code>::</code>, the items being hexadecimal except for
    the last itme, which may consist of four decimal numbers separated by
    <code>.</code> as follows:-->
    is a <i class=common>string</i> representation of a natural number <var>n</var> &lt; 2<sup>128</sup>. 
    It is accurately described by the production rule <var>IPv6address</var>
    in the <a href=https://tools.ietf.org/html/rfc3986#section-3.2.2>Host</a>
    section of <abbr class=-caps>RFC</abbr> 3986. 


  <!-- <h3 id="drive-letters">Drive letters</h3>
  <p>
    The grammar does not have rules for parsing windows drive letters in
    <i>file-<span class=url>URL</span></i>s. It is possible to add that, but together with the
    mode selection, it would complicate the grammar quite a bit. An easier way
    to express this is via a separate operation on parsed <i class=url>URL</i>s.
  <p>
    Drive letter detection, defined using pattern matching:

  <table>
    <tr><td><b>authority</b> (<b>host</b> <var>x</var>)<td>
      ⇒ <td> <b>drive</b> <var>x</var> — if <var>x</var> :: drive-letter
    <tr><td><b>authority</b> (<b>host</b> <var>x</var>・<b>port</b> ε)<td>
      ⇒ <td> <b>drive</b> (<var>x</var>⧺<code>:</code>) <td>
      — <td> if <var>x</var> :: alpha
    <tr><td><var>xs</var>・<b>dir</b> <var>x</var> <td>
      ⇒ <td> <var>xs</var>・<b>drive</b> <var>x</var>・<b>path-root</b> <code>/</code><td>
      — <td> if <var>x</var> :: drive-letter and <var>xs</var> does not contain a <b>dir</b> token
    <tr><td><var>xs</var>・<b>file</b> <var>x</var> <td>
      ⇒ <td> <b>drive</b> <var>x</var><td>
      — <td> if <var>x</var> :: drive-letter and <var>xs</var> does not contain a <b>dir</b> token
  </table>

  <div class=todo>
    No, theres still a problem with the last two rules. This cannot be done
    algebraically, it requires context. You can add path-root to the left, then
    it almost works, but no, still not for e.g. <code>c|/foo</code>.
  </div>

  <p>
    Drive letter detection must not be applied to <i class=url>URL</i>s that
    have a scheme that is not <code>file</code>. It may be applied to
    scheme-less <i class=url>URL</i>s in contexts where
    <i>file-<span class=url>URL</span></i>s are expected. -->


  <h3>A note about repeated slashes</h3>
    <p>
      This is a non-normative sub-section.

    <p>
      Web browsers interpret any amount of slashes after a 
      <i>web-scheme</i> as  the start of the authority component. Consider
      the following <span class=url>URL</span>-strings:

    <div class=-inbetween><ol class=-inline>
      <li><code>http:foo/bar</code>
      <li><code>http:/foo/bar</code>
      <li><code>http://foo/bar</code>
      <li><code>http:///foo/bar</code>
    </ol>.</div>

    <p>
      Web browsers treat all these examples as equivalent to
      <code>http://foo/bar</code>.
      It is tempting to try to express this behaviour on the level of the
      grammar. For example one might consider using the following rule:

    <p class="-inbetween -center">auth-path  :=  s* authority [ path-root [ dir s ]* [ file ] ]

    <p>
      However, the examples above <em>do</em> behave differently with 
      respect to reference resolution. For example, if they are resolved 
      against the <i>base-<span class=url>URL</span></i> that is represented by
      <code>http://host/</code>, then the results are as follows:

    <div class=-inbetween><ol class=-inline>
      <li><code>http://host/foo/bar</code>
      <li><code>http://host/foo/bar</code>
      <li><code>http://foo/bar</code>
      <li><code>http://foo/bar</code>
    </ol>.</div>

    <p>
      As such, collapsing the multiples of slashes, cannot be expressed within 
      the grammar. Instead, the <i>force</i> operation as defined in the 
      chapter on <a>Reference Resolution</a> implements this behaviour. 

</section>


<section><h2>Host processing</h2>

  <div class=todo>
  <ul>
    <li>Percent decode
    <li>Puny decode
    <li>Apply IDNA/ Nameprep normalisation
    <li>Detect IPv4 addresses
    <li>Err on forbidden host codepoints
  </ul>
  </div>

  <h4>IPv4 Address</h4>
  <p>
    An IPv4 address-string consists of one up to four dot-separated numbers with an optional trailing dot. The numbers may use decimal, octal or hexadecimal notation, as follows:

  <table>
    <tr><td>ip4-address <td> ::= <td> ip4num [<code>.</code> ip4num [<code>.</code> ip4num [<code>.</code> ip4num ] ] ] [<code>.</code>]
    <tr><td>ip4num <td> ::= <td> ip4dec | ip4octal | ip4hex
    <tr><td>ip4dec <td> ::= <td> <code>0</code> | (digit-nonzero digit*)
    <tr><td>ip4octal <td> ::= <td> <code>0</code> octaldigit*
    <tr><td>ip4hex <td> ::= <td> (<code>0x</code> | <code>0X</code>) hexdigit*
  </table>

  <p>Note that <code>0x</code> is parsed as a hexadecimal number. (It will be interpreted as 0).
</section>


<section><h2>Reference Resolution</h2>

  <p>
    This section defines a reference resolution operation that is analogous,
    but not equal to the algorithm that is described in the chapter
    <a href="https://tools.ietf.org/html/rfc3986#section-5">Reference
    Resolution</a> of <abbr class=-caps>RFC</abbr> 3986. Likewise, it is
    analogous, but not equal to the &ldquo;basic <i class=url>URL</i> parser&rdquo; that is
    described in the section
    <a href="https://url.spec.whatwg.org/#url-parsing"><i class=url>URL</i> parsing</a> of the
    <abbr class=-caps>WHATWG URL</abbr> standard. The operations shall later be
    used to define a parse-resolve-and-normalise operation that is compatible
    with the <abbr class=-caps>WHATWG URL</abbr> standard.

  <p>
    Reference Resolution as defined in this section does not involve
    <i class=url>URL</i>-strings. It solely operates on <i class=url>URL</i>s as defined in the section
    <a href=#model><i class=url>URL</i> Model</a> above. In contrast with the previously
    mentioned sections in <abbr class=-caps>RFC</abbr> 3986 and in the
    <abbr class=-caps>WHATWG</abbr> standard, it does not do additional 
    normalisation, which is relegated to the section
    <a>Equivalences and Normalisation</a> instead.

    <h4>The Order of an <i class=url>URL</i></h4>
  <p>
    A property that is particularly useful is the <i>order</i> of an
    <i class=url>URL</i>. Colloquially, the order is the
    <i class=common>type</i> of the first <i class=common>token</i>
    of an <i class=url>URL</i>. The order
    may be used as an argument to specify various prefixes of an <i class=url>URL</i>.

  <div class="dfn-scope +br">
    <p class=-br>
      The <dfn>order</dfn> of an <i class=url>URL</i> (<dfn><b class=fn>ord</b></dfn> <var>url</var>) is
      defined to be:
    <ul>
      <li>
        <b>fragment</b> if <var>url</var> is the empty <i class=url>URL</i>.
      <li>
        The <i>type</i> of its first <i class=common>token</i> otherwise.
    </ul>
  </div>

  <div class="dfn-scope +br">
    <p class=-br>
      The <dfn>order-limited prefix</dfn>
      (<var>url</var> <dfn><b class=op>upto</b></dfn> <var>order</var>)
      is defined to be <br>
      the <em>shortest</em> prefix of <var>url</var> that contains:
      <ul>
        <li>
          all <i class=common>token</i>s of <em>url</em> with a type strictly
          smaller than <var>order</var> and
        <li>
          all <b>dir</b> <i class=common>token</i>s with a type weakly smaller
          than <var>order</var>.
    </ul>
  </div>

  <p>
    Based on the order and the order-limited prefix one can define
     &ldquo;goto&rdquo; and &ldquo;nonstrict goto&rdquo; operations that are
    analogous to the &ldquo;merge&rdquo; operation and its nonstrict
    counterpart defined in section
    <a href="https://tools.ietf.org/html/rfc3986#section-5.2.2">Transform
    References</a> of <abbr class=-caps>RFC</abbr> 3986.

  <p>
    I have chosen to rename &ldquo;merge&rdquo; to &ldquo;goto&rdquo; to avert
    the risk of incorrect assumptions about commutativity. 
    The operations are not commutative, but they are associative.

  <h4>Goto</h4>
  <p>
    The <dfn>goto</dfn> operation
    (<var>url<sub>1</sub></var> goto <var>url<sub>2</sub></var>) is defined
    to return <br>
    the <em>shortest</em> <i class=url>URL</i> that has
    <var>url<sub>1</sub></var> <b class=fn>upto</b> (<b class=fn>ord</b> <var>url<sub>2</sub></var>) as a
    prefix and <var>url<sub>2</sub></var> as a postfix.

  <h4>Non-Strict Goto</h4>
  <p class=-br>
    The <dfn>non-strict goto</dfn>
    (<var>url<sub>1</sub></var> <dfn class=op>~goto</dfn> <var>url<sub>2</sub></var>) is defined
    to be<br>
    (<var>url<sub>1</sub></var> <b class=op>goto</b> <var>url<sub>2</var>')
     where <var>url<sub>2</var>' is <var>url<sub>2</var> with its <b>scheme</b>
    <i class=common>token</i> removed if it case-insensitively compares equal
    to the <b>scheme</b> <i class=common>token</i> of <em>url<sub>1</sub></em>,
    or <em>url<sub>2</sub></em> otherwise.<br><br>

  <h4>Properties of the Goto operations</h4>
  <p class=-br>
    The Goto operations have a number of pleasing mathematical properties. 
  <ul>
    <li>
      <i class=op>ord</i> (<var>url<sub>1</sub></var> <i class=op>goto</i> <var>url<sub>2</sub></var>) is the least type of {<i class=op>ord</i> <var>url<sub>1</sub></var>, <i class=op>ord</i> <var>url<sub>2</sub></var>}.
    <li>
      (<var>url<sub>1</sub></var> <i class=op>goto</i> <var>url<sub>2</sub></var>) <i class=op>goto</i> <var>url<sub>3</sub></var> = <var>url<sub>1</sub></var> <i class=op>goto</i> (<var>url<sub>2</sub></var> <i class=op>goto</i> <var>url<sub>3</sub></var>).
    <li>
      ε <i class=op>goto</i> <var>url<sub>2</sub></var> = <var>url<sub>2</sub></var>.
    <li>
      <var>url<sub>1</sub></var> <i class=op>goto</i> ε = <var>url<sub>1</sub></var> — if <var>url<sub>1</sub></var> does not have a <b>fragment</b>.
    <li>
      all of the above are true for <i class=op>~goto</i> as well.
    <li>
      <var>url<sub>2</sub></var> is a postfix of (<var>url<sub>1</sub></var> <i class=op>goto</i> <var>url<sub>2</sub></var>) but not necessarily of (<var>url<sub>1</sub></var> <i class=op>~goto</i> <var>url<sub>2</sub></var>).
  </ul>

  <h4>Force</h4>
  <p>
    There is an additional operation on <i class=url>URL</i>s called
    <i>force</i> that it is used as an error-recovery measure for
    <i>web-<span class=url>URL</span></i>s and for <i>file-<span class=url>URL</span></i>s. Force has no effect on other <i class=url>URL</i>s.


  <div class="dfn-scope +br">
  <ul><li>
    To <dfn>force</dfn> a <i>file-<span class=url>URL</span></i> <var>url</var>:
    <ul>
      <li>
        If <var>url</var> does not have an <b>authority</b> then set its
        <b>authority</b> token to (<b>authority</b> ε).
      <li>
        If <var>url</var> does not a <b>drive</b> then set its 
        <b>path-root</b> token to (<b>path-root</b> <code>/</code>).
    </ul>
    </ul><ul>
    <li>
      To <dfn>force</dfn> a <i>web-<span class=url>URL</span></i>
      <var>url</var>:
    <ul>
      <li>
        If <var>url</var> does not have an <b>authority</b> 
        <i cass=common>token</i>, or if is (<b>authority</b> ε) then let
        <var>token</var> be the first <b>dir</b> or
        <b>file</b> <i class=common>token</i> whose value is not ε. 
        If no such <i class=common>token</i> exists, fail. 
        Remove all <b>dir</b> or <b>file</b> <i class=common>token</i>s that
        precede <var>token</var> and remove <var>token</var> as well. 
        Let <var>auth</var> be the <i>value</i> of <var>token</var> parsed as
        an <i>Authority</i> and set the <b>authority</b> of <var>url</var> to <var>auth</var>. 
      <li>
        Set the <b>path-root</b> of the <i class=url>URL</i> to 
        <code>/</code>. 
    </ul>
  </ul>
  </div>
  <!--<div class=todo>
    Make this clean
  </div>-->

  <p>
    The <i>force</i> operation has some unpleasant mathematical properties
    that will be discussed in the chapter 
    <a>Equivalences and Normalisation</a>. 


  <h3>Resolution</h3>
  <p>
    Finally, reference resolution can be defined.

  <div class="dfn-scope +br">
  <h4>Pre-Resolution</h4>
    <p class=-br>
      The <dfn>pre-resolution</dfn> of <var>url<sub>1</sub></var> against
      <var>url<sub>2</sub></var> is defined to be:
    <ol>
      <li><var>url<sub>2</sub></var> <i class=op>~goto</i> <var>url<sub>1</sub></var>
        — if <var>url<sub>2</sub></var> is a <i>base-<i class=url>URL</i></i> or
        if <var>url<sub>1</sub></var> has a <b>fragment</b> <i class=common>token</i>.
      <li>
        <var>url<sub>1</sub></var> otherwise. 
  </ol>

  <!-- <p>
    The condition 1. checks for the presence of a <b>fragment</b>
    <i class=common>token</i> to emulate the behaviour of the parse-and-resolve
    algorithm of the <abbr class=-caps>WHATWG</abbr> standard.  -->

  <h4>Resolution</h4>
  <p>
    The <dfn>resolution</dfn> of <var>url1</var> against <var>url2</var> is
    defined to be the <i>pre-resolution</i> of <var>url1</var> against
    <var>url2</var>, if it is not ε and its <i>order</i> is <b>scheme</b> or
    <b>fragment</b>.
    Otherwise resolution <strong>fails</strong>. 
  </div>

  <h4>Forced Resolution</h4>
  <p>
    The <dfn>forced resolution</dfn> of <var>url1</var> against
    <var>url2</var> is defined to be the <i>resolution</i> of 
    <var>url1</var> against <var>url2</var>, subsequently  
    <i>force</i>d. 

  <p>
    Note that resolution, defined as such, may return an <i class=url>URL</i> 
    that is not a <i>base-<i class=url>URL</i></i>.
    This emulates the behaviour that is implied by the
    <abbr class=-caps>WHATWG</abbr> standard.

</section>


<section><h2>Equivalences and Normalisation</h2>
  <p>
    This section is analogous to the section
    <a href="https://tools.ietf.org/html/rfc3986#section-6.2">Normalization and 
    Comparison</a> of <abbr class=-caps>RFC</abbr> 3986. The
    <abbr class=-caps>RFC</abbr> however, does not <em>prescribe</em> a
    particular normal form. The <abbr class=-caps>WHATWG</abbr> standard, does, but it does so 
    implicitly.
  <p>
    I think it is nice to define the equivalences via a congruence relation.
    The rules below are specified in such a way that directing them from left
    to right results in a set of terminating rewrite rules. An <i class=url>URL</i> is in normal
    form if no more rewrite rules can be applied. 

<h3>Path Segment Normalisation</h3>

<table>
  <tr><td><b>dir</b>  <var>x</var> <td> ≈ <td>ε <td>—<td> if <var>x</var> :: <i>dot</i></td>
  <tr><td><b>file</b> <var>x</var> <td> ≈ <td>ε <td>—<td> if <var>x</var> :: <i>dot</i></td>

  <tr><td><b>dir</b>  <var>x</var>・<b>dir</b> <var>y</var> <td> ≈ <td> ε                                
    <td> — <td> if <var>y</var> :: <i>dots</i> and <strong>not</strong> <var>x</var> :: <i>dots</i>
  <tr><td><b>dir</b>  <var>x</var>・<b>file</b> <var>y</var> <td> ≈ <td> ε                                
    <td> — <td> if <var>y</var> :: <i>dots</i> and <strong>not</strong> <var>x</var> :: <i>dots</i>

  <tr><td><b>path-root</b> <var>x</var>・<b>dir</b> <var>y</var>  <td> ≈ <td><b>path-root</b> <var>x</var>
    <td> — <td> if <var>y</var> :: <i>dots</i>
  <tr><td><b>path-root</b> <var>x</var>・<b>file</b> <var>y</var> <td> ≈ <td><b>path-root</b> <var>x</var>
    <td> — <td> if <var>y</var> :: <i>dots</i>

  <tr class=-inbetween><td colspan=10>where,
  <tr><td><i>dot</i> <td> ::= <td colspan=10> <code>.</code> | <code>%2e</code> | <code>%2E</code>
  <tr><td><i>dots</i> <td> ::= <td colspan=10> <i>dot</i> <i>dot</i>
</table>

<h3>Authority Normalisation</h3>
  <table>
    <tr><td><b>username</b> ε・<b>password</b> ε <td> ≈ <td>ε
    <tr><td><b>password</b> ε <td> ≈ <td>ε
    <tr><td><b>port</b> ε <td> ≈ <td>ε
  </table>

<h3>Scheme-based Authority Normalisation</h3>
  <table>
    <tr><td><b>scheme</b> <code>file</code> <td>・<td><b>authority</b> (<b>host</b> <code>localhost</code>)          <td> ≈ <td> <b>scheme</b> <code>file</code> <td>・<td><b>authority</b> ε
    <tr><td><b>scheme</b> <code>http</code> <td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>80</code>)  <td> ≈ <td> <b>scheme</b> <code>http</code> <td>・<td><b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>ws</code>   <td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>80</code>)  <td> ≈ <td> <b>scheme</b> <code>ws</code>   <td>・<td><b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>ftp</code>  <td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>21</code>)  <td> ≈ <td> <b>scheme</b> <code>ftp</code>  <td>・<td><b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>wss</code>  <td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>443</code>) <td> ≈ <td> <b>scheme</b> <code>wss</code>  <td>・<td><b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>https</code><td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>443</code>) <td> ≈ <td> <b>scheme</b> <code>https</code><td>・<td><b>authority</b> <var>xs</var>
  </table>
</section>

<ul class=todo>
  <li>norm ((norm url1) goto (norm url2)) = norm (url1 goto url2)
  <li>norm ((norm url1) ~goto (norm url2)) = norm (url1 ~goto url2)
</ul>

<h2 id="validation">Validation</h2>

<div class=todo>
  Additional constraints, validation and failures, all need to be
  expressed in one way or another. 
  This is a bit messy, because, validation warnings and errors may occur on
  multiple levels. For one, the parsing of backslashes. Two, validation
  warnings on invalid code points
</div>

<h2>Percent Coding</h2>

Percent encoding is the process of replacing certain characters in a string
with a percent-escape-sequence. 

<h3>Percent Encoding</h3>

<div class=todo>
  Profiles: ascii, base, special
</div>

<h3>Percent Encode Sets</h3>

<table id=percent-encode-sets class=-lined>
  <tr>
    <th>
    <th colspan=8><b>u+20</b>–<b>u+27</b>
    <th colspan=8><b>u+2F</b>–<b>u+40</b>
    <th colspan=6><b>u+5B</b>–<b>u+60</b>
    <th colspan=6><b>u+7B</b>–<b>u+7E</b>
</table>

<script>
  const table = document.getElementById ('percent-encode-sets')
  for (let x of ['url', 'user', 'host', 'dir', 'file', 'query', 'hash']) {
    var tr = $ ('tr')
    tr.append ($('th', x))
    table.append (tr)
    for (let i=0x20; i<=0x7e; i++) {
      // remove 0-9, a-z, A-Z, '('-'.' and '$', '%' and '&'
      if ((i < 0x28 || i > 0x2e) && (i < 48 || i > 57) && (i < 65 || i > 90) && (i < 97 || i > 122)) {
        const hs = isInSet (i, x)
        const str = String.fromCharCode(i)
        const code = $('code', str == ' ' ? ' ' : str)
        code.title = 'u+'+i.toString(16).toUpperCase() 
        const td = $('td', code)
        if (!hs) td.classList.add ('-screen')
        if (!hs) td.classList.add ('-screen')
        tr.append(td)
      }
    }
    if (x in { dir:1, query:1}) {
    tr = $ ('tr')
    tr.append ($('th', 's'+x))
    table.append (tr)
    for (let i=0x20; i<=0x7e; i++) {
      // remove 0-9, a-z, A-Z, '('-'.'
      if ((i < 0x28 || i > 0x2e) && (i < 48 || i > 57) && (i < 65 || i > 90) && (i < 97 || i > 122)) {
        const hs = isInSet (i, x, { special:true })
        const str = String.fromCharCode(i)
        const td = $('td', $('code', str == ' ' ? ' ' : str))
        if (!hs) td.classList.add ('-screen')
        tr.append(td)
      }
    }
    }
  }
</script>

<h3>Percent Decoding</h3>

<ul class=todo>
  - Decode to byte sequence
  - Decode to code point
  - Recompose string
</ul>


<h2>Printing</h2>
<p>
  Printing is the process of converting an <i class=url>URL</i> to an
  <i><span class=url>URL</span>-string</i>.
<ul>
  <li>
    To print to an <abbr class=-caps>ASCII</abbr>
    <i><span class=url>URL</span>-string</i>, percent encode any \ printable-ascii
  <li>
    Otherwise percent encode c0-control, DEL, c1-control, surrogates and
    non-chars. 
  <li>
    In addition percent encode a subset of printable-ascii, depending on the 
    <i class=common>token</i>, as indicated by the percent coding tables
</ul>

<ul>
  <li>
    Let output be the empty string, then, for each of the
    <i class=common>token</i>s (<var>tag</var>, <var>value</var>) of
    <var>url2</var> in tree order, convert the <i class=common>token</i> to a
    <i class=common>string</i> according to the following table and append
    it to the output.
</ul>

<table id=printer>
  <tr>
  <th><b>scheme</b>
  <th colspan=2><b>authority</b>
  <th><b>drive</b>
  <th><b>root</b>
  <th><b>dir</b>
  <th><b>file</b>
  <th><b>query</b>
  <th><b>fragment</b>
  <tr>
  <td><var>value</var> <code>:</code>
  <td><code>//</code><td><table>
    <tr><th colspan=2>credentials<th><b>host</b><th><b>port</b>
    <tr><td><table>
      <tr><th><b>user</b><th><b>pass</b>
      <tr><td><var>value</var><td><var> <code>:</code> value</var>
    </table><td><code>@</code>
      <td><var>value</var><td><var><code>:</code> value</var>
    </table>
  <td><code>/</code> <var>value</var>
  <td><code>/</code>
  <td><var>value</var> <code>/</code>
  <td><var>value</var>
  <td><code>?</code> <var>value</var>
  <td><code>#</code> <var>value</var>
</table>

</body>
</html>