<!DOCTYPE html>
<html lang="en" class="-debug">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>URL Specification</title>
  <link rel="stylesheet" href="style/base.css">
  <link rel="stylesheet" href="style/style.css">
  <script src="scripts/pct.js"></script>
  <script>
    const log = console.log.bind (console)
    

    const ce = (name, ...subs) => {
      const r = document.createElement (name)
      r.append (...subs)
      return r
    }

    function buildTOC (doc = document) {
      const heads = doc.getElementsByTagName ('H2')
      const toc = doc.getElementById ('toc')
      for (let h of heads)
        if (!h.classList.contains('-toc-exclude'))
        toc.append (ce('li', h.innerText))
    }

    function buildIndex (doc = document) {
      const defs = doc.getElementsByTagName ('DFN')
      const index = { }
      for (let def of defs) {
        // OK so need to define the definition-scope,
        // using a -def-scope class is good, otherwise fall back to the p. 
        let block = getDefScope (def)
        let text = block ? block.innerText.replace(/\s+/, ' ') : ''
        index [def.innerText] = { text, def, block }
      }
      log (index)
      return index
    }
    
  function getDefScope (elem) {
    let block = elem, para = null
    while (block) {
      block = block.parentNode
      para  = block.tagName === 'P' ? block : para
      if (block.classList.contains('-def-scope')) break
      if (block.tagName === 'BODY') block = null
    }
    return block || para
  }
    


  window.addEventListener('DOMContentLoaded', $=> {
    const index = buildIndex ()
    const toolsDiv = document.getElementById ('tools')
    
    const handleClick = evt => {
      let elem = evt.target
      if (evt.target.tagName === 'I') {
        const text = evt.target.innerText.replace(/\s+/, ' ')
        let entry 
        if ((entry = index[text].block)) {
          const block = getDefScope (elem)
          // if (entry.block === block) return
          const tip = entry.cloneNode(true)
          toolsDiv.append (tip)
        }
      }
    }
    document.body.addEventListener ('click', handleClick)
  })

  </script>
</head>
<body>
  
<div id=tools>
</div>

<article>
<h1>URL Specification</h1>

<section>
  <p>
    This document provides a concise formal specification of
    <abbr class=-caps>URL</abbr>s and the language of
    <abbr class=-caps>URL</abbr>s. It is a <em>reverse specification</em> of the
    <a href="https://url.spec.whatwg.org/"><abbr class=-caps>WHATWG-URL</abbr>
      standard</a>.
  <p class=-inbetween>
    The goals of this document are,
  <ul class=-prose>
    <li>
      To provide a modular, concise formal specification that is compatible
      with, and covers all of the <a href="https://url.spec.whatwg.org/"
      ><abbr class=-caps>WHATWG-URL</abbr> standard</a> with the one exception
      being their specification of the web <abbr class=-caps>API</abbr>'s
      setters and the url-encoded form format.
    <li>
      To define a general model for <abbr class=-caps>URL</abbr>s that can
      express relative references and to define reference resolution by means
      of a number of elementary operations, in such a way that the end result
      is compatible with the
      <abbr class=-caps>WHATWG URL</abbr> standard.
    <li>
      To enable and support efforts <em>towards</em> a single
      <strong><em>Unified <abbr class=-caps>URL</abbr> Standard</em></strong>
      that includes a normative specification of <abbr class=-caps>URL</abbr>
      handling by web browsers and that resolves the incompatibilities between
      <a href="https://tools.ietf.org/html/rfc3986"><abbr class=-caps>RFC</abbr> 3986</a>,
      <a href="https://tools.ietf.org/html/rfc3987"><abbr class=-caps>RFC</abbr> 3987</a> and the
      <a href="https://url.spec.whatwg.org/"
      ><abbr class=-caps>WHATWG-URL</abbr> standard</a>.
    <li>
      To provide the authors of the <abbr class=-caps>WHATWG</abbr> standard
      with a support document that they can use as a reference in their efforts
      to standardise the behaviour of web browsers.
  </ul>
</section>

<section><h2 class=-toc-exclude>Status of this document</h2>
  <ul>
    <li>
      This is version 0.2.0 of the specification. This is a development 
      version. 
    <li>
      The versioning scheme is specified by
      <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a>.
    <li>
      This document is licenced under a
      <a href="https://creativecommons.org/licenses/by/4.0/">
      Creative Commons - <abbr class=-caps>CC BY</abbr> 4.0</a> licence. 
  </ul>
</section>

<section><h2 class=-toc-exclude>Structure of this document</h2>
  <p>
    As of this writing, this document has a compact format that is focused
    specifically on the definition and specification of <abbr
     class=-caps>URL</abbr>s and operations on <abbr class=-caps>URL</abbr>s. 
    It does not include a discussion of their history or their use in
    various contexts. It does contain valuable non-normative references to
    <a href="https://tools.ietf.org/html/rfc3986"><abbr class=-caps>RFC</abbr> 3986</a> that can be
    followed for additional information about the concepts involved.

  <p class=-inbetween>
    The sections are laid out as follows.
  <ul id=toc>
    <!-- auto generated -->
  </ul>
  <script>
    window.addEventListener('DOMContentLoaded', $=> buildTOC())
  </script>
</section>

<section><h2>Preliminaries</h2>

  <p>
    This section introduces basic concepts and notational conventions upon 
    which the rest of the specification is built. 

  <h4>Sequences</h4>
  <p>
    This specification uses an algebraic notation for sequences that makes no 
    distinction between one-element sequences and their first element. 
    It uses the following notation. 
  <ul class=-inbetween>
    <li>
      The empty sequence is denoted by ε. 
    <li>
      The concatenation of two sequences <var>S</var> and <var>T</var> is
      denoted by <var>S</var>・<var>T</var>. 
  </ul>
  <p>
    Parentheses are used for disambiguation and as visual aides. Paired 
    parentheses are not used as a sequence-constructing operation. 
      
  <h4>Tokens</h4>
  <p>
    The word <dfn>token</dfn> is used throughout this specification to mean a
    tagged value, (<em>tag</em> <em>value</em>), where the <em>tag</em> is
    taken from a set of predefined <dfn>token-types</dfn>.
  <p>
    Both <i>tag</i> constants and their corresponding token constructing
    operator are typeset in boldface. For example, <b>scheme</b> denotes a 
    <i>tag</i>, whilst (<b>scheme</b> <var>value</var>) denotes a token. 
  <br>
    Again, parentheses are used to disambiguate and as visual aides. 
    They are not part of the token constructing operation. 

  <p>
    The value of a token may be a sequence of tokens itself, in which case
    the token may be referred to as a <dfn>compound token</dfn> for clarity.
    <!--and the tokens present in its value may be referred to as
    <dfn>sub-token</dfn>s.-->
  <p>
    When a collection of tokens contains exactly one sub-token
    (<em>tag</em> <em>value</em>) for a given tag, then the tag may be used
    to refer to its value directly. For example, given a sequence of tokens
    S := (<b>dir</b> <var>x</var>・<b>file</b> <em>y</em>・<b>query</b> <em>z</em>), the prase
      &ldquo;the <b>query</b> of S&rdquo; identifies the value <em>z</em>
      whereas the phrase &ldquo;the <b>query</b> token of S&rdquo; identifies
      (<b>query</b> <em>z</em>).

  <h4>Strings and Code-Points</h4>
  <p class=-line>
    For the purpose of this specification,
  <ul>
    <li>
      A <dfn>string</dfn> is a sequence of <i>character</i>s.
    <li>
      A <dfn>character</dfn> is a single
      <a href="https://www.unicode.org/versions/latest/">Unicode</a>
      <i>code point</i>.
    <li>
      A <dfn>code point</dfn>, is a natural number <var>n</var> ≤ 1114111.
    <li>
      The <dfn>empty string</dfn> is a sequence of zero code points. It is
      denoted by ε. 
  </ul>
  <p>
    Code points are denoted by a number in <em>hexadecimal</em> notation
    preceded by <b>u+</b> in boldface. In addition, code points that correspond
    to printable <abbr class=-caps>ASCII</abbr> characters are often denoted by
    their corresponding glyph, typeset in monospace on a screened background.
    For example, <b>u+41</b> and <code>A</code> denote the same
    code point. Strings that contain only printable
    <abbr class=-caps>ASCII</abbr> characters are often denoted as a 
    connected sequence of glyphs, typeset likewise.
  <p>
    The printable <abbr class=-caps>ASCII</abbr> characters are codepoints in
    the range <b>u+20</b> to <b>u+7E</b>, inclusive. Note that this
    includes the space character <b>u+20</b>.

  <h4>Character Sets</h4>
  <p>
    A <dfn>character range</dfn> is the largest set of characters that includes
    a given least character <var>c</var> and a greatest character <var>d</var>.
    Such a character range is denoted by { <var>c</var>–<var>d</var> }.
    Furthermore, the union of e.g. { <var>a</var>–<var>b</var> }
    and { <var>c</var>–<var>d</var> }, is denoted by
    { <var>a</var>–<var>b</var>, <var>c</var>–<var>d</var> }, and this
    notation is generalised to <var>n</var>-ary unions. Character sets that are 
    used throughout this specification are defined below: 

  <table class=grammar>
    <tr><td>        any <td> := <td> { <b>u+0</b>–<b>u+10FFFF</b> }
    <tr><td> c0-control <td> := <td> { <b>u+0</b>–<b>u+1F</b> }
    <tr><td> printable-<abbr class=-caps>ASCII</abbr><td> := <td> { <b>u+20</b>–<b>u+7E</b> } — i.e. { <code><span style=width:1ch;display:inline-block;padding:0> </span></code>–<code>~</code> }
    <tr><td> octaldigit <td> := <td> { <code>0</code>–<code>7</code> }
    <tr><td>      digit <td> := <td> { <code>0</code>–<code>9</code> }
    <tr><td>   hexdigit <td> := <td> { <code>0</code>–<code>9</code>,  <code>A</code>–<code>F</code>,  <code>a</code>–<code>f</code> }
    <tr><td> digit-nonzero <td> := <td> { <code>1</code>–<code>9</code> }
    <tr><td>      alpha <td> := <td> { <code>A</code>–<code>Z</code>,  <code>a</code>–<code>z</code> }
    <tr><td> c1-control <td> := <td> { <b>u+80</b>–<b>u+9F</b> }
    <tr><td>    latin-1 <td> := <td> { <b>u+A0</b>–<b>u+FF</b> }
    <tr><td>  surrogate <td> := <td> { <b>u+D800</b>–<b>u+DFFF</b> }


  </table>

  <h4>Grammars</h4>
  <p>
    The notation <var>name</var> ::= <var>expression</var> is used to define
    the production rules of a grammar, where the <i>expression</i> uses
    square brackets ( [ _ ] ) <strong>for optional rules</strong>, a postfix
    star ( * ) for zero-or-more, a postfix plus ( + ) for one-or-more, an infix
    vertical line ( | ) for alternatives, monospaced type for literal strings
    and an epsilon ( ε ) for the empty string. Parentheses are used for 
    grouping and disambiguation. 

  <h4>Pattern Matching</h4>
  <p>
    The shorthand notation <var>string</var> :: <var>rule</var> is used to
    express that a string <var>string</var> can be generated by the production
    rule <var>rule</var> of a given grammar. <br>Likewise, the notation 
    <var>string</var> :: <var>expression</var> is used to express that 
    <var>string</var> can be generated by <var>expression</var>.

</section>


<section><h2>URL Model</h2>
<p>
  An <abbr class=-caps>URL</abbr> is a special kind of ordered list that is
  subject to a number of additional constraints. The ordering of the list is
  analogous to the hierarchical syntax of an URI as described in
  <a href="https://tools.ietf.org/html/rfc3986#section-1.2.3">Hierarchical
  Identifiers</a> in <abbr class=-caps>RFC</abbr> 3986.
<p>
  It is important to stress the distinction between an <abbr
   class=-caps>URL</abbr> and an <abbr class=-caps>URL</abbr>-string.
  <br>
  An <abbr class=-caps>URL</abbr> is a <em>structure</em>, indeed a special
  kind of ordered list, whereas an <abbr class=-caps>URL</abbr>-string is a
  special kind of <em>string</em> that <em>represents</em> an <abbr
   class=-caps>URL</abbr>. Conversions between <abbr class=-caps>URL</abbr>s
  and <abbr class=-caps>URL</abbr>-strings are described in the sections on
  <a href="#parsing">parsing</a> and <a href="#printing">printing</a>.

  <h4><abbr class=-caps>URL</abbr></h4>
    <p>
      An <dfn><abbr class=-caps>URL</abbr></dfn> is a sequence of tokens that occur in ascending order by token-type, where token-type is taken from the ordered set: 
    <p class="-center">
      <b>scheme</b> &lt; <b>authority</b> &lt; <b>drive</b> &lt; <b>path-root</b> &lt; <b>dir</b> &lt; <b>file</b> &lt; <b>query</b> &lt; <b>fragment</b>.

    <p>
      <abbr class=-caps>URL</abbr>s are subject to the following constraints:
    <ul>
      <li>
        An <abbr class=-caps>URL</abbr> contains at most one token per type, 
        except for <b>dir</b> tokens, of which it may have any finite amount.
      <li>
        If an <abbr class=-caps>URL</abbr> has an <b>authority</b> or a <b>drive</b> token, and it
        has a <b>dir</b> or a <b>file</b> token, then it also has a
        <b>path-root</b> token.
    </ul>
    <ul>
      <li>
        The <b>scheme</b> of an <abbr class=-caps>URL</abbr>, if present, is a
        string <span class=-nobr><var>scheme</var> :: alpha (alpha | digit | <code>+</code> | <code>-</code> | <code>.</code>)*</span>
      <li>
        The <b>authority</b> of an <abbr class=-caps>URL</abbr>, if present, is
        an <i>Authority</i> — to be defined below.
      <li>
        The <b>drive</b> of an <abbr class=-caps>URL</abbr>, if present, is a
        string <var>drive</var> :: alpha (<code>:</code> | <code>|</code>)
      <li>
        The <b>file</b> of an <abbr class=-caps>URL</abbr>, if present, is a
        nonempty string.
      <li>
        For all other tokens present, the tokens&rsquo; values are strings.
    </ul>


    <div class=-def-scope>
    <h4>Base-<abbr class=-caps>URL</abbr></h4>
    <p>
      A <dfn>base-<abbr class=-caps>URL</abbr></dfn> is an <i><abbr class=-caps>URL</abbr></i> that has a <i><b>scheme</b></i>
      and that has in addition, an <i><b>authority</b></i> or a <i><b>path-root</b></i>.
    </div>


    <div class=-def-scope>
    <h4>Special-<abbr class=-caps>URL</abbr></h4>
      <p>
        An <abbr class=-caps>URL</abbr> is <dfn>special</dfn> if has a <i>special</i> <b>scheme</b>.
        If an <abbr class=-caps>URL</abbr> is not <dfn>special</dfn> then it is said to be <dfn>non-special</dfn>.
        A <i>special</i> <b>scheme</b>  is a string <var>scheme</var> such that:
      <table>
        <tr><td>lowercase (<var>scheme</var>) <td>::<td> <code>http</code> | <code>https</code> | <code>ws</code> | <code>wss</code> | <code>ftp</code> | <code>file</code>
      </table>
    </div>


    <h4>Authority</h4>
    <div class=-def-scope>
    <p>
      An <dfn>Authority</dfn> is a sequence of tokens ordered by their type, 
      taken from the ordered set:

    <p class="-center">
      <b>username</b> &lt; <b>password</b> &lt; <b>host</b> &lt; <b>port</b>.

    <p class=-line>
      Authorities are subject to the following constraints:
    </div>

    <ul>
      <li>
        Authorities contain at most one token per type.
      <li>
        If an Authority has a <b>password</b> token then it also has a
        <b>username</b> token.
      <li>
        If an Authority has a <b>username</b> or a <b>port</b> token
        then it also has a <b>host</b> token. 
    </ul>

    <p class=-line>
      The tokens of an Authority are subject to the following conditions:
    <ul>
      <li>
        The <dfn><b>host</b></dfn> of an Authority is a <i>Host</i> — to be 
        defined below.
      <li>
        The <dfn><b>port</b></dfn> of an Authority, if present, is either the
        empty string ε,<br>or a natural number <var>n</var> &lt; 2<sup>16</sup>.
      <li>
        For all other tokens present, the tokens&rsquo; values are strings.
    </ul>


  <div class=-def-scope>
    <h4>Host</h4>
    <p class=-line>
      A <dfn>Host</dfn> is either
    <ul>
      <li>an ipv6-address,
      <li>an opaque-host, which is a string <var>host</var> :: <i class=rule>opaque-host</i>
      <li>an ipv4-address, or
      <li>a domain-name.
    </ul>
  </div>

  <div class=todo>
    Additional constraints, validation and failures, all need to be
    expressed in one way or another. 
    This is a bit messy, because, validation warnings and errors may occur on
    multiple levels. For one, the parsing of backslashes. Two, validation
    warnings on invalid code points, three, errors, possibly on parsing, else
    higher up. Four. Errors after parsing, such as the host constraints, …
  </div>

  <h3>Additional Constraints</h3>
  <p class=-line>
    If an <abbr class=-caps>URL</abbr> <var>url</var> has a <b>scheme</b> then 
    it is subject to two additional constraints:
    <ul>
  <li>If <var>url</var>'s <b>scheme</b> – converted to lowercase – is 
  <code>file</code> and <var>url</var> has an <b>authority</b> then the authority must not contain a <b>username</b>, <b>password</b> or <b>port</b>.
  <li>Otherwise the <abbr class=-caps>URL</abbr> must not have a <b>drive</b> token.
</ul>
</section>

<section><h2>Parsing</h2>
  <!--<ul>
    <li>An URL-string is a string that represents an URL.
    <li>There are strings that are not URL strings.
    <li>It is possible for a single URL to be represented by more than one URL string.
    <li>URL strings are further divided into valid URL strings and invalid URL strings.
  </ul>-->

  <p>Parsing is stratified into the following phases:

  <ol class=-inbetween>
    <li>Preprocessing.
    <li> Selecting the parser mode.
    <li> Parsing.
    <li> Detecting drive letters.
    <li> Decoding and parsing the host.
  </ol>

  <h3>Preprocessing</h3>
  <p class=-line>
    Before parsing, preprocess the input string <var>input</var> as follows:
  <ul>
    <li>
      Remove all leading and trailing <i>c0-control</i> and <b>u+20</b> 
      (space) characters from <var>input</var>.
    <li>
      Remove all <b>u+9</b> (tab), <b>u+A</b> (line-feed) and <b>u+D</b>
      (carriage-return) characters from <var>input</var>.
  </ul>

  <h3>Parser modes</h3>

  <p>
    The parser mode can be determined by &lsquo;sniffing&rsquo; a scheme from 
    the input before parsing. This can be done in a multiple of ways. 
    Implementors may choose to implement the mode selection within the parser 
    itself. For this specification however, it is useful to specify it as a 
    separate step, before parsing.

  <p class=-inbetween>
    Define the following rules.

  <table class=grammar>
    <tr><td>special-scheme <td> ::= <td> <code>http</code> | <code>https</code> | <code>ws</code> | <code>wss</code> | <code>ftp</code> | <code>file</code>
    <tr><td>is-special <td> ::= <td> special-scheme <code>:</code> any*
    <tr><td>has-scheme <td> ::= <td> alpha (alpha | digit | <code>+</code> | <code>-</code> | <code>.</code>)*<code>:</code> any*
  </table>

  <p class=-inbetween>The mode can be selected as follows.

  <ul>
    <li>Let <em>magic</em> be the first <em>n</em> characters of <em>input</em>, with <em>n</em> being min (6, input.length).
    <li>Set the parser mode to <b>special</b> if (lowercase <em>magic</em>) :: is-special.
    <li>Otherwise if the fallback scheme is <b>special</b> and <em>input</em> :: has-scheme, then set the parse mode to non-special.
  </ul>

  <p>The grammar is parameterised by the parser mode. There are two parser modes, default, and <b>special</b>. In <b>special</b> mode, the s subscripted rules must be used instead of their unsubscripted counterparts, whenever available.


  <h4>URL Grammar</h4>
    <table class=grammar>
      <!-- <tr><td>url <td> ::= <td> [ scheme <code>:</code> ] [ s s authority ] [ path-root ] (dir s)* [ file ] [ <code>?</code> query ] [ <code>#</code> fragment ] -->
      <tr><td>url <td> ::= <td> [ scheme <code>:</code> ] (auth-path | path) [ <code>?</code> query ] [ <code>#</code> fragment ]
      <tr><td>auth-path <td> ::= <td> s s authority [ path-root (dir s)* [ file ] ]
      <tr><td>path <td> ::= <td> [ path-root ] (dir s)* [ file ]

      <tr class=-inbetween>
        <td colspan=3>This refers to the following rules:

      <tr><td>scheme <td> ::= <td> alpha (alpha | digit | <code>+</code> | <code>-</code> | <code>.</code>)*
      <tr><td>authority <td> — <td> shall be defined in the next subsection,
      <tr><td>drive <td> ::= <td> alpha (<code>:</code> | <code>|</code>) — to be used in a subsequent subsection
      <tr><td>path-root <td> ::= <td> slash
      <tr><td>dir <td> ::= <td> pchar*
      <tr><td>file <td> ::= <td> pchar+
      <tr><td>query <td> ::= <td> qchar*
      <tr><td>fragment <td> ::= <td> any*
      <tr><td>s <td> ::= <td> <code>/</code>
      <tr><td>s<sub>S</sub> <td> ::= <td> <code>/</code> | <code>\</code><sub>err</sub>

      <tr class=-inbetween><td colspan=3>These rules are based on the following character sets:

      <tr><td>qchar <td> := <td> any \ {<code>#</code>}
      <tr><td>pchar <td> := <td> any \ {<code>/</code>, <code>#</code>, <code>?</code>}
      <tr><td>pchar<sub>S</sub> <td> := <td> any \ {<code>/</code>, <code>\</code>, <code>#</code>, <code>?</code>}
    </table>

  <h4>Authority Grammar</h4>
    <table class=grammar>
      <tr><td>authority <td> ::= <td> ε | [ credentials <code>@</code> ] host [ <code>:</code> port ]
      <tr><td>credentials <td> ::= <td> username [ <code>:</code> password ]

      <tr class=-inbetween><td colspan=3>This refers to the following rules:

      <tr><td>username <td> ::= <td> uchar*
      <tr><td>password <td> ::= <td> pchar*
      <tr><td>host <td> ::= <td> <code>[</code> ip6-address <code>]</code> | opaque-host
      <tr><td>opaque-host <td> ::= <td> hchar+
      <tr><td>port <td> ::= <td> ε | digit+

      <tr class=-inbetween><td colspan=3>These rules are based on the following character sets:

      <tr><td>uchar <td> := <td> pchar \ { <code>:</code> }
      <!-- <tr><td>hchar <td> := <td> pchar \ { <code>@</code>, <code>:</code> } -->
      <tr><td>hchar <td> := <td> any \ { <b>u+0</b>, <b>u+9</b>, <b>u+A</b>, <b>u+D</b>, <code><span style=display:inline-block;width:1ch> </span></code>, <code>#</code>, <code>/</code>, <code>:</code>, <code>&lt;</code>, <code>&gt;</code>, <code>?</code>, <code>@</code>, <code>[</code>, <code>\</code>, <code>]</code>, <code>^</code> }
      <!-- <tr><td>portchar <td> := <td> pchar \ { <code>@</code> } -->
    </table>

    <div class=todo>
    <ul>
      <li>Host processing
      <li>Evaluating the port
    </ul>
  </div>

  <h4>IPv6 Address</h4>
  <p>
    An IPv6 address-string <!--consists of a sequence of items, separated by
    <code>:</code> or <code>::</code>, the items being hexadecimal except for
    the last itme, which may consist of four decimal numbers separated by
    <code>.</code> as follows:-->
    is a string representation of a natural number <var>n</var> &lt; 2<sup>128</sup>. 
    It is accurately described by the production rule <var>IPv6address</var>
    in the <a href=https://tools.ietf.org/html/rfc3986#section-3.2.2>Host</a>
    section of <abbr class=-caps>RFC</abbr> 3986. 


  <h3>A note about repeated slashes</h3>
    <p>
      This is a non-normative sub-section.

    <p>
      Web browsers interpret any amount of slashes after a special scheme as 
      the start of the authority component. Consider the following <abbr class=-caps>URL</abbr>-strings:

    <div class=-inbetween><ol class=-inline>
      <li><code>http:foo/bar</code>
      <li><code>http:/foo/bar</code>
      <li><code>http://foo/bar</code>
      <li><code>http:///foo/bar</code>
    </ol>.</div>

    <p>
      Web browsers treat all these examples as equivalent to
      <code>http://foo/bar</code>.
      It is tempting to express this behaviour on the level of the grammar. For 
      example one might consider using the following rule:

    <p class="-inbetween -center">auth-path  :=  s* authority [ path-root (dir s)* [ file ] ]

    <p>
      However, the examples above <em>do</em> behave differently with 
      respect to reference resolution. For example, if they are resolved 
      against the base <abbr class=-caps>URL</abbr> that is represented by
      <code>http://host/</code>, then the results are as follows:

    <div class=-inbetween><ol class=-inline>
      <li><code>http://host/foo/bar</code>
      <li><code>http://host/foo/bar</code>
      <li><code>http://foo/bar</code>
      <li><code>http://foo/bar</code>
    </ol>.</div>

    <p>
      As such, collapsing the multiples of slashes, cannot be expressed within 
      the grammar. Instead, the <i>force</i> operation as defined in the 
      chapter on <a>Reference Resolution</a> implements this behaviour. 

  <h3 id="drive-letters">Drive letters</h3>
  <p>
    The grammar does not have rules for parsing windows drive letters in
    <code>file</code> <abbr class=-caps>URL</abbr>s. It is possible to add that, but together with the
    mode selection, it would complicate the grammar quite a bit. An easier way
    to express this is via a separate operation on parsed <abbr class=-caps>URL</abbr>s.
  <p>
    Drive letter detection, defined using pattern matching: 

  <table>
    <tr><td><b>authority</b> (<b>host</b> <var>x</var>)<td>
      ⇒ <td> <b>drive</b> <var>x</var> — if <var>x</var> :: drive-letter
    <tr><td><b>authority</b> (<b>host</b> <var>x</var>・<b>port</b> ε)<td>
      ⇒ <td> <b>drive</b> (<var>x</var>⧺<code>:</code>) <td>
      — <td> if <var>x</var> :: alpha
    <tr><td><var>xs</var>・<b>dir</b> <var>x</var> <td>
      ⇒ <td> <var>xs</var>・<b>drive</b> <var>x</var>・<b>path-root</b> <code>/</code><td>
      — <td> if <var>x</var> :: drive-letter and <var>xs</var> does not contain a <b>dir</b> token
    <tr><td><var>xs</var>・<b>file</b> <var>x</var> <td>
      ⇒ <td> <b>drive</b> <var>x</var><td>
      — <td> if <var>x</var> :: drive-letter and <var>xs</var> does not contain a <b>dir</b> token
  </table>

  <div class=todo>
    No, theres still a problem with the last two rules. This cannot be done algebraically, it requires context. You can add path-root to the left, then it almost works, but no, still not for e.g. <code>c|/foo</code>. 
  </div>

  <p>
    Drive letter detection must not be applied to <abbr class=-caps>URL</abbr>s that have a scheme that
    is not <code>file</code>. It may be applied to schemeless <abbr class=-caps>URL</abbr>s in contexts
    where file <abbr class=-caps>URL</abbr>s are expected.
</section>


<section><h2>Host processing</h2>

  <div class=todo>
  <ul>
    <li>Percent decode
    <li>Puny decode
    <li>Apply IDNA/ Nameprep normalisation
    <li>Detect IPv4 addresses
    <li>Err on forbidden host codepoints
  </ul>
  </div>

  <h4>IPv4 Address</h4>
  <p>
    An IPv4 address-string consists of one up to four dot-separated numbers with an optional trailing dot. The numbers may use decimal, octal or hexadecimal notation, as follows:

  <table>
    <tr><td>ip4-address <td> ::= <td> ip4num [<code>.</code> ip4num [<code>.</code> ip4num [<code>.</code> ip4num ] ] ] [<code>.</code>]
    <tr><td>ip4num <td> ::= <td> ip4dec | ip4octal | ip4hex
    <tr><td>ip4dec <td> ::= <td> <code>0</code> | (digit-nonzero digit*)
    <tr><td>ip4octal <td> ::= <td> <code>0</code> octaldigit*
    <tr><td>ip4hex <td> ::= <td> (<code>0x</code> | <code>0X</code>) hexdigit*
  </table>

  <p>Note that <code>0x</code> is parsed as a hexadecimal number. (It will be interpreted as 0).
</section>


<section><h2>Reference Resolution</h2>

  <p>
    This section defines a reference resolution operation that is analogous,
    but not equal to the algorithm that is described in the chapter
    <a href="https://tools.ietf.org/html/rfc3986#section-5">Reference
    Resolution</a> of <abbr class=-caps>RFC</abbr> 3986. Likewise, it is
    analogous, but not equal to the &ldquo;basic <abbr class=-caps>URL</abbr> parser&rdquo; that is
    described in the section
    <a href="https://url.spec.whatwg.org/#url-parsing"><abbr class=-caps>URL</abbr> parsing</a> of the
    <abbr class=-caps>WHATWG URL</abbr> standard. The operations shall later be
    used to define a parse-resolve-and-normalise operation that is compatible
    with the <abbr class=-caps>WHATWG URL</abbr> standard.

  <p>
    Reference Resolution as defined in this section does not involve
    <abbr class=-caps>URL</abbr>-strings. It solely operates on <abbr class=-caps>URL</abbr>s as defined in the section
    <a href=#model><abbr class=-caps>URL</abbr> Model</a> above. In contrast with the previously
    mentioned sections in <abbr class=-caps>RFC</abbr> 3986 and in the
    <abbr class=-caps>WHATWG</abbr> standard, it does not do additional 
    normalisation, which is relegated to the section
    <a>Equivalences and Normalisation</a> instead.

  <h4>The Order of an <abbr class=-caps>URL</abbr></h4>
  <p>
    A property that is particularily useful is the <i>order</i> of an <abbr class=-caps>URL</abbr>.
    Colloquially, the order is the type of the first token of an <abbr class=-caps>URL</abbr>. The order
    may be used as an argument to specify various prefixes of an <abbr class=-caps>URL</abbr>.

  <p class=-line>
    The <dfn>order</dfn> of an <abbr class=-caps>URL</abbr> (<b class=fn>ord</b> <var>url</var>) is
    defined to be:
  <ul>
    <li>
      <b>fragment</b> if <var>url</var> is the empty <abbr class=-caps>URL</abbr>.
    <li>
      The type of its first token otherwise.
  </ul>

  <p class=-line>
    The <dfn>order-limited prefix</dfn>
    (<var>url</var> <span class=op>upto</span> <var>order</var>)
    is defined to be <br>
    the <em>shortest</em> prefix of <var>url</var> that contains:
    <ul>
      <li>
        all tokens of <em>url</em> with a type strictly smaller than
        <var>order</var> and
      <li>
        all <b>dir</b> tokens with a type weakly smaller than
        <var>order</var>.
  </ul>

  <p>
    Based on the order and the order-limited prefix one can define
     &ldquo;goto&rdquo; and &ldquo;nonstrict goto&rdquo; operations that are
    analogous to the &ldquo;merge&rdquo; operation and its nonstrict
    counterpart defined in section
    <a href="https://tools.ietf.org/html/rfc3986#section-5.2.2">Transform
    References</a> of <abbr class=-caps>RFC</abbr> 3986.

  <p>
    I have chosen to rename &ldquo;merge&rdquo; to &ldquo;goto&rdquo; to avert
    the risk of incorrect assumptions about commutativity. 
    The operations are not commutative, but they are associative.

  <h4>Goto</h4>
  <p>
    The <dfn>goto</dfn> operation
    (<var>url<sub>1</sub></var> goto <var>url<sub>2</sub></var>) is defined
    to return <br>
    the <em>shortest</em> <abbr class=-caps>URL</abbr> that has
    <var>url<sub>1</sub></var> upto (ord <var>url<sub>2</sub></var>) as a
    prefix and <var>url<sub>2</sub></var> as a postfix.

  <h4>Non-Strict Goto</h4>
  <p class=-line>
    The <dfn>non-strict goto</dfn>
    (<var>url<sub>1</sub></var> ~goto <var>url<sub>2</sub></var>) is defined
    to be<br>
    (<var>url<sub>1</sub></var> goto <var>url<sub>2</var>') where
    <var>url<sub>2</var>' is <var>url<sub>2</var> with the <b>scheme</b>
    token removed if it case-insensitively compares equal to the <b>scheme</b>
    token of <em>url<sub>1</sub></em>, or <em>url<sub>2</sub></em>
    otherwise.<br><br>

  <h4>Properties of the Goto operations</h4>
  <p class=-line>
    The Goto operations have a number of pleasing mathematical properties. 
  <ul>
    <li>
      ord (<var>url<sub>1</sub></var> goto <var>url<sub>2</sub></var>) is the least type of {ord <var>url<sub>1</sub></var>, ord <var>url<sub>2</sub></var>}.
    <li>
      (<var>url<sub>1</sub></var> goto <var>url<sub>2</sub></var>) goto <var>url<sub>3</sub></var> = <var>url<sub>1</sub></var> goto (<var>url<sub>2</sub></var> goto <var>url<sub>3</sub></var>).
    <li>
      ε goto <var>url<sub>2</sub></var> = <var>url<sub>2</sub></var>.
    <li>
      <var>url<sub>1</sub></var> goto ε = <var>url<sub>1</sub></var> — if <var>url<sub>1</sub></var> does not have a <b>fragment</b>.
    <li>
      all of the above are true for ~goto as well.
    <li>
      <var>url<sub>2</sub></var> is a postfix of (<var>url<sub>1</sub></var> goto <var>url<sub>2</sub></var>) but not necessarily of (<var>url<sub>1</sub></var> ~goto <var>url<sub>2</sub></var>).
  </ul>

  <h4>Force</h4>
  <p>
    There is an additional operation on <abbr class=-caps>URL</abbr>s called <em>force</em> that 
    it is used as an error-recovery measure for special <abbr class=-caps>URL</abbr>s that have an
    empty, or an absent authority. Force has no effect on <i>non-special</i>
    <abbr class=-caps>URL</abbr>s. 

  <div class=-def-scope>
  <ul><li>
    To <dfn>force</dfn> a file <abbr class=-caps>URL</abbr>:
    <ul>
      <li>
        Set its <b>authority</b> token to (<b>authority</b> ε) if absent.
      <li>
        Set its <b>path-root</b> token to (<b>path-root</b> <code>/</code>) unless it
        has a <b>drive</b>.
    </ul>
    </ul><ul>
    <li>
      To <dfn>force</dfn> any other special <abbr class=-caps>URL</abbr>
    <ul>
      <li>
        If the <abbr class=-caps>URL</abbr> does not have an <b>authority</b> 
        or if it is ε then let <var>token</var> be the first <b>dir</b> or
        <b>file</b> token whose value is not ε. 
        If no such token exists, fail. 
        Remove all <b>dir</b> or <b>file</b> tokens that precede 
        <var>token</var> and remove <var>token</var> as well. 
        Let <var>auth</var> be the <i>value</i> of <var>token</var> parsed as
        an <i>Authority</i> and set the <b>authority</b> of the
        <abbr class=-caps>URL</abbr> to <var>auth</var>. 
      <li>
        Set the <b>path-root</b> of the <abbr class=-caps>URL</abbr> to 
        <code>/</code>. 
    </ul>
  </ul>
  </div>
  <!--<div class=todo>
    Make this clean
  </div>-->

  <p>
    The <i>force</i> operation has some unpleasant mathematical properties
    that will be discussed in the chapter 
    <a>Equivalences and Normalisation</a>. 


  <h3>Resolution</h3>
  <p>
    Finally, reference resolution can be defined.

  <h4>Pre-Resolution</h4>
    <p class=-line>
      The <dfn>pre-resolution</dfn> of <var>url</var> against an
      <var>url2</var> is defined to be:
    <ol>
      <li><var>url2</var> ~goto <var>url1</var> — if <var>url2</var> is a
        <i>base-<abbr class=-caps>URL</abbr></i> or if <var>url1</var> has a <b>fragment</b> token.
      <li>
        <var>url1</var> otherwise. 
  </ol>

  <p>
    The condition 1. checks for the presence of a <b>fragment</b> token
    to emulate the behaviour of the parse-and-resolve algorithm of the
    <abbr class=-caps>WHATWG</abbr> standard. 

  <h4>Resolution</h4>
  <p>
    The <dfn>resolution</dfn> of <var>url1</var> against <var>url2</var> is
    defined to be the <i>pre-resolution</i> of <var>url1</var> against
    <var>url2</var>, if it is not ε and its order is <b>scheme</b> or
    <b>fragment</b>.
    Otherwise resolution <strong>fails</strong>. 

  <h4>Forced Resolution</h4>
  <p>
    The <dfn>forced resolution</dfn> of <var>url1</var> against
    <var>url2</var> is defined to be the <i>resolution</i> of 
    <var>url1</var> against <var>url2</var>, subsequently  
    <i>force</i>d. 

  <p>
    Note that resolution, defined as such, may return an <abbr class=-caps>URL</abbr> that consists of
    only a <b>fragment</b> and is therefore not a <i>base-<abbr class=-caps>URL</abbr></i>.
    This emulates the behaviour that is implied by the
    <abbr class=-caps>WHATWG</abbr> standard.

</section>


<section><h2>Equivalences and Normalisation</h2>
  <p>
    This section is analogous to the section
    <a href="https://tools.ietf.org/html/rfc3986#section-6.2">Normalization and 
    Comparison</a> of <abbr class=-caps>RFC</abbr> 3986. The
    <abbr class=-caps>RFC</abbr> however, does not <em>prescribe</em> a
    particular normal form. The <abbr class=-caps>WHATWG</abbr> standard, does, but it does so 
    implicitly.
  <p>
    I think it is nice to define the equivalences via a congruence relation.
    The rules below are specified in such a way that directing them from left
    to right results in a set of terminating rewrite rules. An <abbr class=-caps>URL</abbr> is in normal
    form if no more rewrite rules can be applied. 

<h4>Path Segment Normalisation</h4>

<table>
  <tr><td><b>dir</b>  <var>x</var> <td> ≈ <td>ε <td>—<td> if <var>x</var> :: <i>dot</i></td>
  <tr><td><b>file</b> <var>x</var> <td> ≈ <td>ε <td>—<td> if <var>x</var> :: <i>dot</i></td>

  <tr><td><b>dir</b>  <var>x</var>・<b>dir</b> <var>y</var> <td> ≈ <td> ε                                
    <td> — <td> if <var>y</var> :: <i>dots</i> and <strong>not</strong> <var>x</var> :: <i>dots</i>
  <tr><td><b>dir</b>  <var>x</var>・<b>file</b> <var>y</var> <td> ≈ <td> ε                                
    <td> — <td> if <var>y</var> :: <i>dots</i> and <strong>not</strong> <var>x</var> :: <i>dots</i>

  <tr><td><b>path-root</b> <var>x</var>・<b>dir</b> <var>y</var>  <td> ≈ <td><b>path-root</b> <var>x</var>
    <td> — <td> if <var>y</var> :: <i>dots</i>
  <tr><td><b>path-root</b> <var>x</var>・<b>file</b> <var>y</var> <td> ≈ <td><b>path-root</b> <var>x</var>
    <td> — <td> if <var>y</var> :: <i>dots</i>

  <tr class=-inbetween><td colspan=10>where,
  <tr><td><i>dot</i> <td> ::= <td colspan=10> <code>.</code> | <code>%2e</code> | <code>%2E</code>
  <tr><td><i>dots</i> <td> ::= <td colspan=10> <i>dot</i> <i>dot</i>
</table>

<h4 id="authority-normalisation">Authority Normalisation</h3>
  <table>
    <tr><td><b>username</b> ε・<b>password</b> ε <td> ≈ <td>ε
    <tr><td><b>password</b> ε <td> ≈ <td>ε
    <tr><td><b>port</b> ε <td> ≈ <td>ε
  </table>

<h4>Scheme-based Authority Normalisation</h4>
  <table>
    <tr><td><b>scheme</b> <code>file</code> <td>・<td><b>authority</b> (<b>host</b> <code>localhost</code>)          <td> ≈ <td> <b>scheme</b> <code>file</code> <td>・<td><b>authority</b> ε
    <tr><td><b>scheme</b> <code>http</code> <td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>80</code>)  <td> ≈ <td> <b>scheme</b> <code>http</code> <td>・<td><b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>ws</code>   <td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>80</code>)  <td> ≈ <td> <b>scheme</b> <code>ws</code>   <td>・<td><b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>ftp</code>  <td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>21</code>)  <td> ≈ <td> <b>scheme</b> <code>ftp</code>  <td>・<td><b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>wss</code>  <td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>443</code>) <td> ≈ <td> <b>scheme</b> <code>wss</code>  <td>・<td><b>authority</b> <var>xs</var>
    <tr><td><b>scheme</b> <code>https</code><td>・<td><b>authority</b> (<var>xs</var>・<b>port</b> <code>443</code>) <td> ≈ <td> <b>scheme</b> <code>https</code><td>・<td><b>authority</b> <var>xs</var>
  </table>
</section>

<h2 id="validation">Validation</h2>

<h2>Percent Coding</h2>

<h2>Printing</h2>
<p>
  Printing is the process of converting an <abbr class=-caps>URL</abbr> to an
  <abbr class=-caps>URL</abbr>-string.
<ul>
  <li>
    To print to an <abbr class=-caps>ASCII</abbr> <abbr class=-caps>URL</abbr>-string, percent encode any \ printable-ascii
  <li>
    Otherwise percent encode c0-control, DEL, c1-control, surrogates and
    non-chars. 
  <li>
    In addition percent encode a subset of printable-ascii, depending on the 
    token, as indicated by the tables below. 
</ul>

<table id=percent-encode-sets>
</table>

<script>
  const table = document.getElementById ('percent-encode-sets')
  for (let x of ['url', 'user', 'host', 'dir', 'file', 'query', 'hash']) {
    var tr = ce ('tr')
    tr.append (ce('th', x))
    table.append (tr)
    for (let i=0x20; i<=0x7e; i++) {
      // remove 0-9, a-z, A-Z, '('-'.' and '$', '%' and '&'
      if ((i < 0x28 || i > 0x2e) && (i < 48 || i > 57) && (i < 65 || i > 90) && (i < 97 || i > 122)) {
        const hs = isInSet (i, x)
        const str = String.fromCharCode(i)
        const code = ce('code', str == ' ' ? ' ' : str)
        code.title = 'u+'+i.toString(16).toUpperCase() 
        const td = ce('td', code)
        if (!hs) td.classList.add ('-screen')
        if (!hs) td.classList.add ('-screen')
        tr.append(td)
      }
    }
    if (x in { dir:1, query:1}) {
    tr = ce ('tr')
    tr.append (ce('th', 's'+x))
    table.append (tr)
    for (let i=0x20; i<=0x7e; i++) {
      // remove 0-9, a-z, A-Z, '('-'.'
      if ((i < 0x28 || i > 0x2e) && (i < 48 || i > 57) && (i < 65 || i > 90) && (i < 97 || i > 122)) {
        const hs = isInSet (i, x, { special:true })
        const str = String.fromCharCode(i)
        const td = ce('td', ce('code', str == ' ' ? ' ' : str))
        if (!hs) td.classList.add ('-screen')
        tr.append(td)
      }
    }
    }
  }
</script>

<ul>
  <li>Let output be the empty string, then, for each of the tokens (<em>type</em>, <em>value</em>) of <em>url2</em> in tree order, convert the token to a string according to the following table and append it to the output.
</ul>

<table id=printer>
  <tr>
  <th><b>scheme</b>
  <th colspan=2><b>authority</b>
  <th><b>drive</b>
  <th><b>root</b>
  <th><b>dir</b>
  <th><b>file</b>
  <th><b>query</b>
  <th><b>fragment</b>
  <tr>
  <td><var>value</var> <code>:</code>
  <td><code>//</code><td><table>
    <tr><th colspan=2>credentials<th><b>host</b><th><b>port</b>
    <tr><td><table>
      <tr><th><b>user</b><th><b>pass</b>
      <tr><td><var>value</var><td><var> <code>:</code> value</var>
    </table><td><code>@</code>
      <td><var>value</var><td><var><code>:</code> value</var>
    </table>
  <td><code>/</code> <var>value</var>
  <td><code>/</code>
  <td><var>value</var> <code>/</code>
  <td><var>value</var>
  <td><code>?</code> <var>value</var>
  <td><code>#</code> <var>value</var>
</table>

</body>
</html>